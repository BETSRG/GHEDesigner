{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"GHEDesigner - A Flexible and Automatic Ground Heat Exchanger Design Tool","text":""},{"location":"#introduction","title":"Introduction","text":"<p>GHEDesigner is a Python package for designing ground heat exchangers (GHE) used with ground source heat pump (GSHP) systems. Compared to currently available tools such as GLHEPRO, GHEDesigner:</p> <ul> <li>is flexible. It can synthesize borehole fields that are custom fit to the user's property description,</li> <li>implements the RowWise algorithm (Spitler, et al. 2022a) for   automatically placing and sizing boreholes in any land area with complex geometry,</li> <li>is highly automated. It can select library configurations or custom configurations and determine the final number and   depth requirement of boreholes,</li> <li>can make automated conversion of hourly loads to an improved hybrid time step   representation (Cullin and Spitler 2011), and</li> <li>is under continuing development at Oklahoma State University (OSU), Oak Ridge National Laboratory (ORNL), and the   National Laboratory of the Rockies (NLR). (GLHEPRO remains under development at OSU.)</li> </ul>"},{"location":"#background","title":"Background","text":"<p>GHEDesigner was originally funded through US Department of Energy contract DE\u2010AC05\u201000OR22725 via a subcontract from Oak Ridge National Laboratory. The project led by Dr. Xiaobing Liu developed an online screening tool (Liu, et al. 2022) for techno-economic analysis and design of ground-source heat pump systems. The Oklahoma State University team led by Prof. Jeffrey D. Spitler was contracted to investigate fast methods for computing g-functions. An outgrowth of this research was a tool for automatically selecting and sizing borehole configurations. This tool, originally called GHEDT, is described in an MS thesis (Cook 2021). Since that time, the tool has been renamed GHEDesigner, and work has continued at Oklahoma State University, Oak Ridge National Laboratory, and the National Laboratory of the Rockies.</p> <p>Updates since Cook (2021) include:</p> <ul> <li>Development and addition of RowWise algorithm to efficiently place boreholes in the available land area.</li> <li>Extensive refactoring for creating a user-focused, stable API.</li> <li>Simplification of library dependencies.</li> <li>Development of automated testing and deployment procedures.</li> </ul>"},{"location":"#borehole-field-design-algorithms","title":"Borehole Field Design Algorithms","text":"<ul> <li>Long time-step g-functions are calculated using pygfunction (Cimmino 2018) using the equivalent borehole   method (Prieto and Cimmino 2021). It's also possible to read   g-functions from a library (Spitler, et al. 2021).</li> <li>Borehole thermal resistance is computed for single and double U-tube configurations via the multipole   method (Claesson and Hellstr\u00f6m 2011). For coaxial ground heat   exchangers, it is computed from fundamental heat transfer relationships.</li> <li>Short time-step g-functions are computed using the   Xu and Spitler (2006) method.</li> <li>GHEDesigner contains a novel design methodology for automated selection of borehole fields. The advanced methodology   performs optimization based on a target drilling depth. An integer bisection routine is utilized to quickly search   over a uni-modal domain of boreholes. GHEDesigner can consider the available land area for drilling and no-drilling   zones defined as polygons.</li> <li>GHEDesigner can synthesize a range of regularly shaped borehole configurations, including previously available   shapes (rectangles, open rectangles, L-shape, U-shape, line) and shapes not previously available (C-shapes and zoned   rectangles). More information about these shapes can be found in the documentation for a publicly available g-function   library. (Spitler, et al. 2021, 2022b)</li> <li>GHEDesigner can synthesize on the fly irregularly shaped borehole configurations using the RowWise   algorithm (Spitler, et al. 2022a) or the bi-uniform polygonal constrained   rectangular search (BUPCRS) (Cook 2021). Both configurations are adapted to the   user-specified property boundaries and no-drill zones, if any. Spitler, et al. 2022a   gives an example where the RowWise algorithm saves 12-18% compared to the BUPCRS algorithm. The RowWise algorithm takes   longer to run, though.</li> <li>A set of search routines can be used to size different types of configurations:</li> <li>The unconstrained square/near-square search will search a domain of square (n x n) and near-square     (n-1 x n) boreholes fields, with uniform spacing between the boreholes.</li> <li>Uniform and bi-uniform constrained rectangular searches will search domains of rectangular configurations that     have either uniform spacing or \"bi-uniform\" spacing \u2013 that is, uniform in the x direction and uniform in the y     direction, but the two spacings may be different.</li> <li>The bi-uniform constrained zoned rectangular search allows for rectangular configurations with different interior     and perimeter spacings.</li> <li>The bi-uniform polygonal constrained rectangular search (BUPCRS) can search configurations with an outer perimeter     and no-go zones described as irregular polygons. This is still referred to as a rectangular search because it is     still based on a rectangular grid, from which boreholes that are outside the perimeter or inside a no-go zone are     removed.</li> <li>The RowWise method generates and searches custom borehole fields that make full use of the available property. The     RowWise algorithms are described by Spitler et al. (2022a).</li> </ul>"},{"location":"#limitations","title":"Limitations","text":"<p>GHEDesigner does not have every feature that is found in a tool like GLHEPRO. Features that are currently missing include:</p> <ul> <li>Heat pumps are not modeled. Users input heat rejection/extraction rates.</li> <li>An hourly simulation is available, but it doesn't make use of load aggregation, so is very slow.</li> <li>GHEDesigner only covers vertical borehole ground heat exchangers. Horizontal ground heat exchangers are not treated.</li> <li>GHEDesigner does not calculate the head loss in the ground heat exchanger or warn the user that head loss may be   excessive.</li> <li>GHEDesigner does not have a graphical user interface.</li> <li>GHEDesigner is a Python package and requires some Python knowledge to use.</li> </ul>"},{"location":"#requirements","title":"Requirements","text":"<p>GHEDesigner is supported for Python versions &gt;= 3.10, and is tested with Python 3.10-3.13. GHEDesigner is dependent on the following packages:</p> <ul> <li>click</li> <li>jsonschema</li> <li>numpy</li> <li>pygfunction</li> <li>scipy</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<p>Users - Install <code>GHEDesigner</code> via the package installer for Python (pip):</p> <pre><code>pip install ghedesigner\n</code></pre> <p>Run a demo file using GHEDesigner:</p> <pre><code>ghedesigner demos/find_design_rectangle_single_u_tube.json ./tmp\n</code></pre> <p>Developers - Clone the repository via git:</p> <pre><code>git clone git@github.com:BETSRG/GHEDesigner.git\n</code></pre> <ul> <li>uv is used to manage the project &amp; dependencies. After cloning (and with uv installed at   the system level), run <code>uv sync</code>.</li> <li>Developers can then call <code>pytest</code> (which may take 10-30 minutes to run the full test suite) to confirm all dev   dependencies have been installed and everything is working as expected.</li> <li>Activate pre-commit (only required once, after cloning the repo) with:   <code>pre-commit install</code>. On your first commit it will install the pre-commit environments, then run pre-commit hooks at   every commit.</li> <li>Before pushing to GitHub, run pre-commit on all files with <code>pre-commit run -a</code> to highlight any linting/formatting   errors that will cause CI to fail.</li> <li>PyCharm users may need to add Ruff as a 3rd-party plugin or install it as an   external tool to their IDE to ensure linting &amp; formatting is consistent.</li> </ul>"},{"location":"#updating-documentation","title":"Updating documentation","text":"<p>During development, we can serve docs locally and view updates with every save.</p> <ol> <li>Start a documentation update branch: <code>git checkout -b &lt;branch_name&gt;</code></li> <li><code>mkdocs serve</code></li> <li>Point browser to http://localhost:8000/</li> </ol>"},{"location":"#questions","title":"Questions","text":"<p>If there are any questions, comments or concerns please create an issue, comment on an open issue, comment on a closed issue.</p>"},{"location":"#acknowledgements","title":"Acknowledgements","text":"<p>The initial release of this work was financially supported by the U.S. Department of Energy through research subcontracts from Oak Ridge National Laboratory and the National Laboratory of the Rockies, and by OSU through the Center for Integrated Building Systems, the OG&amp;E Energy Technology Chair, and Oklahoma State University via return of indirect costs to Dr. Jeffrey D. Spitler.</p>"},{"location":"#references","title":"References","text":"<ul> <li> <p>Cimmino, M. 2018. pygfunction: an open-source toolbox for the evaluation of thermal. eSim 2018, Montre\u00e1l, IBPSA Canada.   492-501. http://www.ibpsa.org/proceedings/eSimPapers/2018/2-3-A-4.pdf</p> </li> <li> <p>Claesson, J. and G. Hellstr\u00f6m. 2011. Multipole method to calculate borehole thermal resistances in a borehole heat   exchanger. HVAC&amp;R Research 17(6): 895-911. https://doi.org/10.1080/10789669.2011.609927</p> </li> <li> <p>Cook, J.C. (2021). Development of Computer Programs for Fast Computation of g-Functions and Automated Ground Heat   Exchanger Design. Master's Thesis, Oklahoma State University, Stillwater, OK. https://hdl.handle.net/11244/335489</p> </li> <li> <p>Cullin, J.R. and J.D. Spitler. 2011. A Computationally Efficient Hybrid Time Step Methodology for Simulation of Ground   Heat Exchangers. Geothermics. 40(2): 144-156. https://doi.org/10.1016/j.geothermics.2011.01.001</p> </li> <li> <p>Liu X., J. Degraw, M. Malhotra, W. Forman, M. Adams, G. Accawi, B. Brass, N. Kunwar, J. New, J. Guo. 2022. Development   of a Web-based Screening Tool for Ground Source Heat Pump Applications. 2022. IGSHPA Research Conference Proceedings.   Pp. 280-290. December 6-8. Las Vegas. http://dx.doi.org/10.22488/okstate.22.000042</p> </li> <li> <p>Prieto, C. and M. Cimmino. 2021. Thermal interactions in large irregular fields of geothermal boreholes: the method of   equivalent boreholes. Journal of Building Performance Simulation 14(4):   446-460. https://doi.org/10.1080/19401493.2021.1968953</p> </li> <li> <p>Spitler, J. D., J. Cook, T. West and X. Liu 2021. G-Function Library for Modeling Vertical Bore Ground Heat Exchanger,   Oak Ridge National Laboratory. https://doi.org/10.15121/1811518</p> </li> <li> <p>Spitler, J.D., T.N. West and X. Liu. 2022a. Ground Heat Exchanger Design Tool with RowWise Placement of Boreholes.   IGSHPA Research Conference Proceedings. Pp. 53-60. Las Vegas. Dec. 6-8. https://doi.org/10.22488/okstate.22.000016</p> </li> <li> <p>Spitler, J.D., T.N. West, X. Liu and I. Borshon. 2022b. An open library of g-functions for 34,321 configurations. IGSHPA   Research Conference Proceedings. Pp. 264-271. Las Vegas. Dec. 6-8 https://doi.org/10.22488/okstate.22.000040</p> </li> <li> <p>Xu, X. and J. D. Spitler. 2006. Modelling of Vertical Ground Loop Heat Exchangers with Variable Convective Resistance   and Thermal Mass of the Fluid. 10th International Conference on Thermal Energy Storage - Ecostock 2006, Pomona,   NJ. https://hvac.okstate.edu/sites/default/files/pubs/papers/2006/07-Xu_Spitler_06.pdf</p> </li> </ul>"},{"location":"cli/","title":"Command Line Interface","text":"<p>This library comes with a command line interface. Once this library is pip installed, a new binary executable will be available with the name <code>ghedesigner</code>. The command has a help argument with output similar to this (execute manually to verify latest syntax):</p> <pre><code>$ ghedesigner --help\nUsage: ghedesigner [OPTIONS] INPUT_PATH [OUTPUT_DIRECTORY]\n\nOptions:\n  --version           Show the version and exit.\n  --validate-only     Validate input file and exit.\n  -c, --convert TEXT  Convert output to specified format. Options supported:\n                      'IDF'.\n  --help              Show this message and exit.\n</code></pre>"},{"location":"examples/","title":"Examples","text":""},{"location":"examples/#api-example-usage","title":"API Example Usage","text":"<p>A basic programmatic example is shown below. Additional examples are found at https://github.com/BETSRG/GHEDesigner/tree/main/ghedesigner/tests</p> <pre><code>ghe = GroundHeatExchanger()\nghe.set_single_u_tube_pipe(\n    inner_diameter=0.03404,\n    outer_diameter=0.04216,\n    shank_spacing=0.01856,\n    roughness=1.0e-6,\n    conductivity=0.4,\n    rho_cp=1542000.0,\n)\nghe.set_soil(conductivity=2.0, rho_cp=2343493.0, undisturbed_temp=18.3)\nghe.set_grout(conductivity=1.0, rho_cp=3901000.0)\nghe.set_fluid()\nghe.set_borehole(buried_depth=2.0, diameter=0.140)\nghe.set_simulation_parameters(num_months=240, max_eft=35, min_eft=5, max_height=135, min_height=60)\nghe.set_ground_loads_from_hourly_list(self.get_atlanta_loads())\nghe.set_geometry_constraints_rectangle(length=85.0, width=36.5, b_min=3.0, b_max=10.0)\nghe.set_design(flow_rate=0.5, flow_type_str=\"borehole\")\nghe.find_design()\n</code></pre>"},{"location":"examples/#command-line-example-usage","title":"Command Line Example Usage","text":"<p>A basic command line example is shown below. Demo files can be found at https://github.com/BETSRG/GHEDesigner/tree/main/demos</p> <pre><code>  $ ghedesigner path/to/my_file.json path/to/output_dir/\n</code></pre>"},{"location":"manager/","title":"Design Manager","text":""},{"location":"manager/#full-documentation-of-the-groundheatexchanger-class","title":"Full documentation of the GroundHeatExchanger class","text":"Source code in <code>ghedesigner/ghe/manager.py</code> <pre><code>class GroundHeatExchanger:  # TODO: Rename this.  Just GHEDesignerManager?  GHEDesigner?\n    def __init__(\n        self,\n        grout_conductivity: float,\n        grout_rho_cp: float,\n        soil_conductivity: float,\n        soil_rho_cp: float,\n        soil_undisturbed_temperature: float,\n        borehole_buried_depth: float,\n        borehole_radius: float,\n        pipe_arrangement_type: PipeType,\n        pipe_parameters: dict,\n        fluid_name: str = \"Water\",\n        fluid_concentration_percent: float = 0.0,\n        fluid_temperature: float = 20.0,\n    ) -&gt; None:\n        self.fluid = Fluid(fluid_name, fluid_temperature, fluid_concentration_percent)\n        self.grout = Grout(grout_conductivity, grout_rho_cp)\n        self.soil = Soil(soil_conductivity, soil_rho_cp, soil_undisturbed_temperature)\n        if pipe_arrangement_type == PipeType.SINGLEUTUBE:\n            params = [\"conductivity\", \"rho_cp\", \"inner_diameter\", \"outer_diameter\", \"shank_spacing\", \"roughness\"]\n            if not all(x in pipe_parameters for x in params):\n                raise ValueError(f\"pipe_arrangement_type of {pipe_arrangement_type!s} requires these inputs: {params}\")\n            pipe_parameters[\"num_pipes\"] = 1\n            self.pipe = Pipe.init_single_u_tube(**pipe_parameters)\n        elif pipe_arrangement_type == PipeType.DOUBLEUTUBESERIES:\n            params = [\"conductivity\", \"rho_cp\", \"inner_diameter\", \"outer_diameter\", \"shank_spacing\", \"roughness\"]\n            if not all(x in pipe_parameters for x in params):\n                raise ValueError(f\"pipe_arrangement_type of {pipe_arrangement_type!s} requires these inputs: {params}\")\n            self.pipe = Pipe.init_double_u_tube_series(**pipe_parameters)\n        elif pipe_arrangement_type == PipeType.DOUBLEUTUBEPARALLEL:\n            params = [\"conductivity\", \"rho_cp\", \"inner_diameter\", \"outer_diameter\", \"shank_spacing\", \"roughness\"]\n            if not all(x in pipe_parameters for x in params):\n                raise ValueError(f\"pipe_arrangement_type of {pipe_arrangement_type!s} requires these inputs: {params}\")\n            self.pipe = Pipe.init_double_u_tube_parallel(**pipe_parameters)\n        else:  # Assuming coaxial\n            params = [\n                \"conductivity_inner\",\n                \"rho_cp\",\n                \"conductivity_outer\",\n                \"inner_pipe_d_in\",\n                \"inner_pipe_d_out\",\n                \"outer_pipe_d_in\",\n                \"outer_pipe_d_out\",\n            ]\n            if not all(x in pipe_parameters for x in params):\n                raise ValueError(f\"pipe_arrangement_type of {PipeType.COAXIAL!s} requires these inputs: {params}\")\n            pipe_parameters[\"conductivity\"] = (\n                pipe_parameters[\"conductivity_inner\"],\n                pipe_parameters[\"conductivity_outer\"],\n            )\n            del pipe_parameters[\"conductivity_inner\"]\n            del pipe_parameters[\"conductivity_outer\"]\n            self.pipe = Pipe.init_coaxial(**pipe_parameters)\n        self.pygfunction_borehole = Borehole(100, borehole_buried_depth, borehole_radius, x=0.0, y=0.0)\n\n    @classmethod\n    def init_from_dictionary(cls, ghe_dict: dict, fluid_inputs: dict | None = None) -&gt; \"GroundHeatExchanger\":\n        \"\"\"\n        Initialize a GroundHeatExchanger object from input dictionaries, performing validation and ultimately calling\n        the main object constructor.\n        :param ghe_dict: Dictionary of ground heat exchanger parameters, see the input schema specification for required\n                         inputs in the ground_heat_exchanger schema field.\n        :param fluid_inputs: Optional dictionary of fluid input parameters, see the input schema fluid spec for details.\n        :return: GroundHeatExchanger object.\n        # TODO: Add validation back in to the input fields\n        \"\"\"\n        grout_parameters: dict = ghe_dict[\"grout\"]\n        g_c: float = grout_parameters[\"conductivity\"]\n        g_rho_cp: float = grout_parameters[\"rho_cp\"]\n\n        soil_parameters: dict = ghe_dict[\"soil\"]\n        s_k: float = soil_parameters[\"conductivity\"]\n        s_rho_cp: float = soil_parameters[\"rho_cp\"]\n        s_temp: float = soil_parameters[\"undisturbed_temp\"]\n\n        borehole_parameters: dict = ghe_dict[\"borehole\"]\n        buried_depth: float = borehole_parameters[\"buried_depth\"]\n        diameter: float = borehole_parameters[\"diameter\"]\n        radius: float = diameter / 2.0\n\n        fluid_dict = (\n            fluid_inputs if fluid_inputs else {\"fluid_name\": \"Water\", \"concentration_percent\": 0.0, \"temperature\": 20.0}\n        )\n        fluid_name = fluid_dict.get(\"fluid_name\", \"Water\")\n        concentration_percent = fluid_dict.get(\"concentration_percent\", 0.0)\n        temperature = fluid_dict.get(\"temperature\", 20.0)\n\n        pipe_parameters: dict = ghe_dict[\"pipe\"]\n        pipe_type: PipeType = PipeType(pipe_parameters[\"arrangement\"].upper())\n        del pipe_parameters[\"arrangement\"]\n\n        ghe: GroundHeatExchanger = cls(\n            g_c,\n            g_rho_cp,\n            s_k,\n            s_rho_cp,\n            s_temp,\n            buried_depth,\n            radius,\n            pipe_type,\n            pipe_parameters,\n            fluid_name,\n            concentration_percent,\n            temperature,\n        )\n        return ghe\n\n    def design_and_size_ghe(self, ghe_dict: dict, end_month: int, loads_override: list[float] | None = None):\n        ghe_loads = loads_override if loads_override else get_loads(ghe_dict[\"loads\"])\n\n        if (end_month % MONTHS_IN_YEAR) &gt; 0:\n            raise ValueError(f\"end_month must be a multiple of {MONTHS_IN_YEAR}\")\n\n        flow_type_str: str = ghe_dict[\"flow_type\"]\n        flow_type = FlowConfigType(flow_type_str.upper())\n        flow_rate: float = ghe_dict[\"flow_rate\"]\n\n        # grab some design conditions\n        design_parameters = ghe_dict[\"design\"]\n        continue_if_design_unmet: bool = design_parameters.get(\"continue_if_design_unmet\", False)\n        min_eft: float = design_parameters[\"min_eft\"]\n        max_eft: float = design_parameters[\"max_eft\"]\n        max_height: float = design_parameters[\"max_height\"]\n        min_height: float = design_parameters[\"min_height\"]\n        max_boreholes: int | None = design_parameters.get(\"max_boreholes\")\n        # check_arg_bounds(min_eft, max_eft, \"min_eft\", \"max_eft\")\n\n        # set up the geometry constraints section\n        geom = ghe_dict[\"geometric_constraints\"]\n        geometry_map = {geom.name: geom for geom in DesignGeomType}\n        geom_type = geometry_map.get(geom[\"method\"].upper())\n        design: DesignBase\n\n        match geom_type:\n            case DesignGeomType.RECTANGLE:\n                # max_height: float, min_height: float, length: float, width: float, b_min: float, b_max: float\n                rect_geometry: GeometricConstraintsRectangle = GeometricConstraintsRectangle(\n                    length=geom[\"length\"],\n                    width=geom[\"width\"],\n                    b_min=geom[\"b_min\"],\n                    b_max=geom[\"b_max\"],\n                )\n                design = DesignRectangle(\n                    flow_rate,\n                    self.pygfunction_borehole,\n                    self.fluid,\n                    self.pipe,\n                    self.grout,\n                    self.soil,\n                    1,\n                    end_month,\n                    max_eft,\n                    min_eft,\n                    max_height,\n                    min_height,\n                    continue_if_design_unmet,\n                    max_boreholes,\n                    rect_geometry,\n                    ghe_loads,\n                    flow_type=flow_type,\n                    method=TimestepType.HYBRID,\n                )\n            case DesignGeomType.NEARSQUARE:\n                near_sq_geometry: GeometricConstraintsNearSquare = GeometricConstraintsNearSquare(\n                    b=geom[\"b\"],\n                    length=geom[\"length\"],\n                )\n                design = DesignNearSquare(\n                    flow_rate,\n                    self.pygfunction_borehole,\n                    self.fluid,\n                    self.pipe,\n                    self.grout,\n                    self.soil,\n                    1,\n                    end_month,\n                    max_eft,\n                    min_eft,\n                    max_height,\n                    min_height,\n                    continue_if_design_unmet,\n                    max_boreholes,\n                    near_sq_geometry,\n                    ghe_loads,\n                    flow_type=flow_type,\n                    method=TimestepType.HYBRID,\n                )\n            case DesignGeomType.BIRECTANGLE:\n                bi_rect_geometry: GeometricConstraintsBiRectangle = GeometricConstraintsBiRectangle(\n                    length=geom[\"length\"],\n                    width=geom[\"width\"],\n                    b_min=geom[\"b_min\"],\n                    b_max_x=geom[\"b_max_x\"],\n                    b_max_y=geom[\"b_max_y\"],\n                )\n                design = DesignBiRectangle(\n                    flow_rate,\n                    self.pygfunction_borehole,\n                    self.fluid,\n                    self.pipe,\n                    self.grout,\n                    self.soil,\n                    1,\n                    end_month,\n                    max_eft,\n                    min_eft,\n                    max_height,\n                    min_height,\n                    continue_if_design_unmet,\n                    max_boreholes,\n                    bi_rect_geometry,\n                    ghe_loads,\n                    flow_type=flow_type,\n                    method=TimestepType.HYBRID,\n                )\n            case DesignGeomType.BIZONEDRECTANGLE:\n                bi_zoned_geometry: GeometricConstraintsBiZoned = GeometricConstraintsBiZoned(\n                    length=geom[\"length\"],\n                    width=geom[\"width\"],\n                    b_min=geom[\"b_min\"],\n                    b_max_x=geom[\"b_max_x\"],\n                    b_max_y=geom[\"b_max_y\"],\n                )\n                design = DesignBiZoned(\n                    flow_rate,\n                    self.pygfunction_borehole,\n                    self.fluid,\n                    self.pipe,\n                    self.grout,\n                    self.soil,\n                    1,\n                    end_month,\n                    max_eft,\n                    min_eft,\n                    max_height,\n                    min_height,\n                    continue_if_design_unmet,\n                    max_boreholes,\n                    bi_zoned_geometry,\n                    ghe_loads,\n                    flow_type=flow_type,\n                    method=TimestepType.HYBRID,\n                )\n            case DesignGeomType.BIRECTANGLECONSTRAINED:\n                no_go_boundaries = geom.get(\"no_go_boundaries\", None)\n                bi_rect_const_geometry: GeometricConstraintsBiRectangleConstrained = (\n                    GeometricConstraintsBiRectangleConstrained(\n                        b_min=geom[\"b_min\"],\n                        b_max_x=geom[\"b_max_x\"],\n                        b_max_y=geom[\"b_max_y\"],\n                        property_boundary=geom[\"property_boundary\"],\n                        no_go_boundaries=no_go_boundaries,\n                    )\n                )\n                design = DesignBiRectangleConstrained(\n                    flow_rate,\n                    self.pygfunction_borehole,\n                    self.fluid,\n                    self.pipe,\n                    self.grout,\n                    self.soil,\n                    1,\n                    end_month,\n                    max_eft,\n                    min_eft,\n                    max_height,\n                    min_height,\n                    continue_if_design_unmet,\n                    max_boreholes,\n                    bi_rect_const_geometry,\n                    ghe_loads,\n                    flow_type=flow_type,\n                    method=TimestepType.HYBRID,\n                )\n            case DesignGeomType.ROWWISE:\n                # use perimeter calculations if present\n                perimeter_spacing_ratio = geom.get(\"perimeter_spacing_ratio\", None)\n                spacing_step = geom.get(\"spacing_step\", 0)\n                no_go_boundaries = geom.get(\"no_go_boundaries\", None)\n                geometry_row: GeometricConstraintsRowWise = GeometricConstraintsRowWise(\n                    perimeter_spacing_ratio=perimeter_spacing_ratio,\n                    max_spacing=geom[\"max_spacing\"],\n                    min_spacing=geom[\"min_spacing\"],\n                    spacing_step=spacing_step,\n                    max_rotation=geom[\"max_rotation\"] * DEG_TO_RAD,\n                    min_rotation=geom[\"min_rotation\"] * DEG_TO_RAD,\n                    rotate_step=geom[\"rotate_step\"],\n                    property_boundary=geom[\"property_boundary\"],\n                    no_go_boundaries=no_go_boundaries,\n                )\n                design = DesignRowWise(\n                    flow_rate,\n                    self.pygfunction_borehole,\n                    self.fluid,\n                    self.pipe,\n                    self.grout,\n                    self.soil,\n                    1,\n                    end_month,\n                    max_eft,\n                    min_eft,\n                    max_height,\n                    min_height,\n                    continue_if_design_unmet,\n                    max_boreholes,\n                    geometry_row,\n                    ghe_loads,\n                    flow_type=flow_type,\n                    method=TimestepType.HYBRID,\n                )\n            case _:\n                raise ValueError(f'DesignGeomType \"{geom_type}\" not supported')\n\n        start_time = time()\n        search = design.find_design()  # TODO: I wonder if it would simplify things to just return the GHE object\n        search_time = time() - start_time\n        found_ghe = cast(GHE, search.ghe)\n        found_ghe.compute_g_functions(min_height, max_height)\n        found_ghe.size(TimestepType.HYBRID, max_height, min_height, max_eft, min_eft)\n        return search, search_time, found_ghe\n\n    def get_g_function(self, ghe_dict: dict, boundary_condition=\"MIFT\") -&gt; tuple[ndarray, ndarray, ndarray]:\n        # TODO: Create a SingleUTube class or something in order to get the STS stitched up\n        pre_designed = ghe_dict[\"pre_designed\"]\n        borehole_height: float = pre_designed[\"H\"]\n        if pre_designed[\"arrangement\"] == \"MANUAL\":\n            x_positions: Sequence[float] = pre_designed[\"x\"]\n            y_positions: Sequence[float] = pre_designed[\"y\"]\n            if len(x_positions) != len(y_positions):\n                raise RuntimeError(\"Borehole location coordinate mismatch, make sure length of x and y are equal\")\n            locations = list(zip(x_positions, y_positions))\n        elif pre_designed[\"arrangement\"] == \"RECTANGLE\":\n            num_bh_x = pre_designed[\"boreholes_in_x_dimension\"]\n            num_bh_y = pre_designed[\"boreholes_in_y_dimension\"]\n            spacing_x = pre_designed[\"spacing_in_x_dimension\"]\n            spacing_y = pre_designed[\"spacing_in_y_dimension\"]\n            locations = rectangle(num_bh_x, num_bh_y, spacing_x, spacing_y)\n        else:\n            raise RuntimeError(\"Invalid arrangement type for pre_designed borehole field\")\n\n        nbh = len(locations)\n        flow_rate: float = ghe_dict[\"flow_rate\"]\n        flow_type_str: str = str(ghe_dict[\"flow_type\"]).upper()\n\n        if flow_type_str == FlowConfigType.BOREHOLE.name:\n            m_flow_borehole = flow_rate * self.fluid.rho / 1000  # conv lps to m3s to kgs\n        elif flow_type_str == FlowConfigType.SYSTEM.name:\n            m_flow_ghe = flow_rate * self.fluid.rho / 1000  # conv lps to m3s to kgs\n            m_flow_borehole = m_flow_ghe / nbh\n        else:\n            raise NotImplementedError(f\"FlowConfigType {flow_type_str} not implemented.\")\n\n        self.pygfunction_borehole.H = borehole_height\n        ts = borehole_height**2 / (9 * self.soil.alpha)\n        log_time_lts = eskilson_log_times()\n        time_values = exp(log_time_lts) * ts\n\n        g_lts = calculate_g_function(\n            m_flow_borehole,\n            self.pipe.type,\n            time_values,\n            locations,\n            self.pygfunction_borehole,\n            self.fluid,\n            self.pipe,\n            self.grout,\n            self.soil,\n            boundary_condition=boundary_condition,\n        )\n\n        single_u_bh = SingleUTube(\n            m_flow_borehole, self.fluid, self.pygfunction_borehole, self.pipe, self.grout, self.soil\n        )\n\n        log_time_sts, g_sts = single_u_bh.calc_sts_g_functions()\n        g_bhw = single_u_bh.g_bhw\n\n        g_interp = combine_sts_lts(\n            log_time_lts,\n            g_lts.tolist(),\n            log_time_sts.tolist(),\n            g_sts.tolist(),\n        )\n\n        g_bhw_interp = combine_sts_lts(\n            log_time_lts,\n            g_lts.tolist(),\n            log_time_sts.tolist(),\n            g_bhw.tolist(),\n        )\n\n        log_time_to_write = array(log_time_sts.tolist() + log_time_lts)\n        g_to_write = g_interp(log_time_to_write)\n        g_bhw_to_write = g_bhw_interp(log_time_to_write)\n\n        return log_time_to_write, g_to_write, g_bhw_to_write\n</code></pre>"},{"location":"manager/#ghedesigner.ghe.manager.GroundHeatExchanger.init_from_dictionary","title":"<code>init_from_dictionary(ghe_dict, fluid_inputs=None)</code>  <code>classmethod</code>","text":"<p>Initialize a GroundHeatExchanger object from input dictionaries, performing validation and ultimately calling the main object constructor.</p> <p>Parameters:</p> Name Type Description Default <code>ghe_dict</code> <code>dict</code> <p>Dictionary of ground heat exchanger parameters, see the input schema specification for required inputs in the ground_heat_exchanger schema field.</p> required <code>fluid_inputs</code> <code>dict | None</code> <p>Optional dictionary of fluid input parameters, see the input schema fluid spec for details.</p> <code>None</code> <p>Returns:</p> Type Description <code>GroundHeatExchanger</code> <p>GroundHeatExchanger object. # TODO: Add validation back in to the input fields</p> Source code in <code>ghedesigner/ghe/manager.py</code> <pre><code>@classmethod\ndef init_from_dictionary(cls, ghe_dict: dict, fluid_inputs: dict | None = None) -&gt; \"GroundHeatExchanger\":\n    \"\"\"\n    Initialize a GroundHeatExchanger object from input dictionaries, performing validation and ultimately calling\n    the main object constructor.\n    :param ghe_dict: Dictionary of ground heat exchanger parameters, see the input schema specification for required\n                     inputs in the ground_heat_exchanger schema field.\n    :param fluid_inputs: Optional dictionary of fluid input parameters, see the input schema fluid spec for details.\n    :return: GroundHeatExchanger object.\n    # TODO: Add validation back in to the input fields\n    \"\"\"\n    grout_parameters: dict = ghe_dict[\"grout\"]\n    g_c: float = grout_parameters[\"conductivity\"]\n    g_rho_cp: float = grout_parameters[\"rho_cp\"]\n\n    soil_parameters: dict = ghe_dict[\"soil\"]\n    s_k: float = soil_parameters[\"conductivity\"]\n    s_rho_cp: float = soil_parameters[\"rho_cp\"]\n    s_temp: float = soil_parameters[\"undisturbed_temp\"]\n\n    borehole_parameters: dict = ghe_dict[\"borehole\"]\n    buried_depth: float = borehole_parameters[\"buried_depth\"]\n    diameter: float = borehole_parameters[\"diameter\"]\n    radius: float = diameter / 2.0\n\n    fluid_dict = (\n        fluid_inputs if fluid_inputs else {\"fluid_name\": \"Water\", \"concentration_percent\": 0.0, \"temperature\": 20.0}\n    )\n    fluid_name = fluid_dict.get(\"fluid_name\", \"Water\")\n    concentration_percent = fluid_dict.get(\"concentration_percent\", 0.0)\n    temperature = fluid_dict.get(\"temperature\", 20.0)\n\n    pipe_parameters: dict = ghe_dict[\"pipe\"]\n    pipe_type: PipeType = PipeType(pipe_parameters[\"arrangement\"].upper())\n    del pipe_parameters[\"arrangement\"]\n\n    ghe: GroundHeatExchanger = cls(\n        g_c,\n        g_rho_cp,\n        s_k,\n        s_rho_cp,\n        s_temp,\n        buried_depth,\n        radius,\n        pipe_type,\n        pipe_parameters,\n        fluid_name,\n        concentration_percent,\n        temperature,\n    )\n    return ghe\n</code></pre>"},{"location":"schema/ghedesigner.schema/","title":"JSON Schema","text":""},{"location":"schema/ghedesigner.schema/#properties","title":"Properties","text":"<ul> <li><code>topology</code> (array, required): A list of name/type map objects that define the system topology.</li> <li>Items (object): Cannot contain additional properties.<ul> <li><code>name</code> (string, required): Length must be at least 1.</li> <li><code>type</code> (string, required): Length must be at least 1.</li> </ul> </li> <li><code>fluid</code> (object, required): A fluid definition object. Cannot contain additional properties.</li> <li><code>fluid_name</code> (string, required): Circulation fluid type. Must be one of: \"WATER\", \"ETHYLALCOHOL\", \"ETHYLENEGLYCOL\", \"METHYLALCOHOL\", or \"PROPYLENEGLYCOL\".</li> <li><code>concentration_percent</code> (number, format: Percent, required): Mass fraction concentration percent of circulation fluid. e.g.: '0' indicates pure water; '20' indicates 20% antifreeze, 80% pure water. Minimum: <code>0</code>. Maximum: <code>60</code>.</li> <li><code>temperature</code> (number, format: Centigrade, required): Average design fluid temperature at peak conditions.</li> <li><code>building</code> (object): A map of available building definition objects. Can contain additional properties.</li> <li>Additional properties (object): Cannot contain additional properties.<ul> <li><code>name</code> (string, required)</li> <li><code>loads</code> (string, required)</li> <li><code>cop</code> (number, required)</li> <li><code>capacity</code> (string, required)</li> </ul> </li> <li><code>ground_heat_exchanger</code> (object, required): A collection of objects that define a ground heat exchanger system. Can contain additional properties.</li> <li>Additional properties (object): Cannot contain additional properties.<ul> <li><code>flow_rate</code> (number, format: Liters/Second, required): Volumetric design flow rate. Value specified will be either the system or per-borehole flow rate depending on the 'flow_type' set. Minimum: <code>0</code>.</li> <li><code>flow_type</code> (string, required): Indicates whether the design volumetric flow rate set on on a per-borehole or system basis. Must be one of: \"BOREHOLE\" or \"SYSTEM\".</li> <li><code>grout</code> (object, required): Cannot contain additional properties.</li> <li><code>conductivity</code> (required): Refer to #/$defs/conductivity.</li> <li><code>rho_cp</code> (required): Refer to #/$defs/rho_cp.</li> <li><code>soil</code> (object, required): Cannot contain additional properties.</li> <li><code>conductivity</code> (required): Refer to #/$defs/conductivity.</li> <li><code>rho_cp</code> (required): Refer to #/$defs/rho_cp.</li> <li><code>undisturbed_temp</code> (number, format: Centigrade, required): Undisturbed, far-field soil temperature.</li> <li><code>pipe</code> (object, required)</li> <li>One of<ul> <li>: Cannot contain additional properties.</li> <li><code>arrangement</code>: Must be: <code>\"SINGLEUTUBE\"</code>.</li> <li><code>inner_diameter</code> (required): Refer to #/$defs/inner_diameter.</li> <li><code>outer_diameter</code> (required): Refer to #/$defs/outer_diameter.</li> <li><code>shank_spacing</code> (required): Refer to #/$defs/shank_spacing.</li> <li><code>roughness</code> (required): Refer to #/$defs/roughness.</li> <li><code>conductivity</code> (required): Refer to #/$defs/conductivity.</li> <li><code>rho_cp</code> (required): Refer to #/$defs/rho_cp.</li> <li><code>num_pipes</code> (integer): Number of single U-tube pipes in the borehole. Default is 1. Minimum: <code>1</code>. Default: <code>1</code>.</li> <li>: Cannot contain additional properties.</li> <li><code>arrangement</code>: Must be: <code>\"DOUBLEUTUBESERIES\"</code>.</li> <li><code>inner_diameter</code> (required): Refer to #/$defs/inner_diameter.</li> <li><code>outer_diameter</code> (required): Refer to #/$defs/outer_diameter.</li> <li><code>shank_spacing</code> (required): Refer to #/$defs/shank_spacing.</li> <li><code>roughness</code> (required): Refer to #/$defs/roughness.</li> <li><code>conductivity</code> (required): Refer to #/$defs/conductivity.</li> <li><code>rho_cp</code> (required): Refer to #/$defs/rho_cp.</li> <li>: Cannot contain additional properties.</li> <li><code>arrangement</code>: Must be: <code>\"DOUBLEUTUBEPARALLEL\"</code>.</li> <li><code>inner_diameter</code> (required): Refer to #/$defs/inner_diameter.</li> <li><code>outer_diameter</code> (required): Refer to #/$defs/outer_diameter.</li> <li><code>shank_spacing</code> (required): Refer to #/$defs/shank_spacing.</li> <li><code>roughness</code> (required): Refer to #/$defs/roughness.</li> <li><code>conductivity</code> (required): Refer to #/$defs/conductivity.</li> <li><code>rho_cp</code> (required): Refer to #/$defs/rho_cp.</li> <li>: Cannot contain additional properties.</li> <li><code>arrangement</code>: Must be: <code>\"COAXIAL\"</code>.</li> <li><code>inner_pipe_d_in</code> (number, format: Meters, required): Inner pipe inner diameter. Minimum: <code>0</code>.</li> <li><code>inner_pipe_d_out</code> (number, format: Meters, required): Inner pipe outer diameter. Minimum: <code>0</code>.</li> <li><code>outer_pipe_d_in</code> (number, format: Meters, required): Outer pipe inner diameter. Minimum: <code>0</code>.</li> <li><code>outer_pipe_d_out</code> (number, format: Meters, required): Outer pipe outer diameter. Minimum: <code>0</code>.</li> <li><code>roughness</code> (required): Refer to #/$defs/roughness.</li> <li><code>conductivity_inner</code> (number, format: Watts/Meters-Kelvin, required): Thermal conductivity of inner pipe. Minimum: <code>0</code>.</li> <li><code>conductivity_outer</code> (number, format: Watts/Meter-Kelvin, required): Thermal conductivity of outer pipe. Minimum: <code>0</code>.</li> <li><code>rho_cp</code> (required): Refer to #/$defs/rho_cp.</li> </ul> </li> <li><code>arrangement</code> (string): Pipe arrangement specified. Must be one of: \"SINGLEUTUBE\", \"DOUBLEUTUBESERIES\", \"DOUBLEUTUBEPARALLEL\", or \"COAXIAL\".</li> <li><code>borehole</code> (object, required): Cannot contain additional properties.</li> <li><code>buried_depth</code> (number, format: Meters, required): Depth of top of borehole below the ground surface. Minimum: <code>0</code>.</li> <li><code>diameter</code> (number, format: Meters, required): Diameter of borehole.</li> <li><code>pre_designed</code> (object): Data related to a pre-designed borehole field, used in cases where the field arrangement is known ahead of time. GHEDesigner will provide a g-function calculation for the specified field.</li> <li>One of<ul> <li>: Cannot contain additional properties.</li> <li><code>arrangement</code>: Must be: <code>\"MANUAL\"</code>.</li> <li><code>H</code> (required): Refer to #/$defs/H.</li> <li><code>x</code> (array, required): For MANUAL arrangement, this provides an array of x coordinate positions, one for each borehole in the field.<ul> <li>Items (number)</li> </ul> </li> <li><code>y</code> (array, required): For MANUAL arrangement, this provides an array of y coordinate positions, one for each borehole in the field.<ul> <li>Items (number)</li> </ul> </li> <li>: Cannot contain additional properties.</li> <li><code>arrangement</code>: Must be: <code>\"RECTANGLE\"</code>.</li> <li><code>H</code> (required): Refer to #/$defs/H.</li> <li><code>boreholes_in_x_dimension</code> (integer, required): Number of boreholes in the x direction of the field, dimensionless. Minimum: <code>0</code>.</li> <li><code>boreholes_in_y_dimension</code> (integer, required): Number of boreholes in the y direction of the field, dimensionless. Minimum: <code>0</code>.</li> <li><code>spacing_in_x_dimension</code> (number, format: Meters, required): Borehole spacing in the x direction of the field, in meters (ignored if boreholes_in_x_dimension = 1). Minimum: <code>0</code>.</li> <li><code>spacing_in_y_dimension</code> (number, format: Meters, required): Borehole spacing in the y direction of the field, in meters (ignored if boreholes_in_y_dimension = 1). Minimum: <code>0</code>.</li> </ul> </li> <li><code>arrangement</code> (string): Pipe arrangement specified. Must be one of: \"MANUAL\" or \"RECTANGLE\".</li> <li><code>geometric_constraints</code> (object)</li> <li>One of<ul> <li>: Cannot contain additional properties.</li> <li><code>method</code>: Must be: <code>\"BIRECTANGLE\"</code>.</li> <li><code>length</code> (required): Refer to #/$defs/length.</li> <li><code>width</code> (required): Refer to #/$defs/width.</li> <li><code>b_min</code> (required): Refer to #/$defs/b_min.</li> <li><code>b_max_x</code> (required): Refer to #/$defs/b_max_x.</li> <li><code>b_max_y</code> (required): Refer to #/$defs/b_max_y.</li> <li>: Cannot contain additional properties.</li> <li><code>method</code>: Must be: <code>\"BIRECTANGLECONSTRAINED\"</code>.</li> <li><code>b_min</code> (required): Refer to #/$defs/b_min.</li> <li><code>b_max_x</code> (required): Refer to #/$defs/b_max_x.</li> <li><code>b_max_y</code> (required): Refer to #/$defs/b_max_y.</li> <li><code>property_boundary</code> (required): Refer to #/$defs/property_boundary.</li> <li><code>no_go_boundaries</code>: Refer to #/$defs/no_go_boundaries.</li> <li>: Cannot contain additional properties.</li> <li><code>method</code>: Must be: <code>\"BIZONEDRECTANGLE\"</code>.</li> <li><code>length</code> (required): Refer to #/$defs/length.</li> <li><code>width</code> (required): Refer to #/$defs/width.</li> <li><code>b_min</code> (required): Refer to #/$defs/b_min.</li> <li><code>b_max_x</code> (required): Refer to #/$defs/b_max_x.</li> <li><code>b_max_y</code> (required): Refer to #/$defs/b_max_y.</li> <li>: Cannot contain additional properties.</li> <li><code>method</code>: Must be: <code>\"NEARSQUARE\"</code>.</li> <li><code>length</code> (required): Refer to #/$defs/length.</li> <li><code>b</code> (number, format: Meters, required): Borehole-to-borehole spacing. Minimum: <code>0</code>.</li> <li>: Cannot contain additional properties.</li> <li><code>method</code>: Must be: <code>\"RECTANGLE\"</code>.</li> <li><code>length</code> (required): Refer to #/$defs/length.</li> <li><code>width</code> (required): Refer to #/$defs/width.</li> <li><code>b_min</code> (required): Refer to #/$defs/b_min.</li> <li><code>b_max</code> (required): Refer to #/$defs/b_max.</li> <li>: Cannot contain additional properties.</li> <li><code>method</code>: Must be: <code>\"ROWWISE\"</code>.</li> <li><code>min_spacing</code> (number, format: Meters, required): The smallest minimum spacing that will be used to generate a RowWise field. Minimum: <code>0</code>.</li> <li><code>max_spacing</code> (number, format: Meters, required): The largest minimum spacing that will be used to generate a RowWise field. Minimum: <code>0</code>.</li> <li><code>spacing_step</code> (number, format: Meters): The distance in spacing from the design found in the first part of first search to exhaustively check in the second part. Minimum: <code>0</code>.</li> <li><code>min_rotation</code> (number, format: Degrees, required): The minimum rotation of the rows of each field relative to horizontal that will be used in the search. Minimum: <code>-90</code>. Maximum: <code>90</code>.</li> <li><code>max_rotation</code> (number, format: Degrees, required): The maximum rotation of the rows of each field relative to horizontal that will be used in the search. Minimum: <code>-90</code>. Maximum: <code>90</code>.</li> <li><code>rotate_step</code> (number, format: Degrees, required): Step size for field rotation search.</li> <li><code>property_boundary</code> (required): Refer to #/$defs/property_boundary.</li> <li><code>no_go_boundaries</code>: Refer to #/$defs/no_go_boundaries.</li> <li><code>perimeter_spacing_ratio</code> (number, format: fraction): The ratio between the minimum spacing between boreholes placed along the property and no-go zones and the standard borehole-to-borehole spacing used for internal boreholes. Minimum: <code>0</code>.</li> </ul> </li> <li><code>method</code> (string): Design algorithm specified. Must be one of: \"BIRECTANGLE\", \"BIRECTANGLECONSTRAINED\", \"BIZONEDRECTANGLE\", \"NEARSQUARE\", \"RECTANGLE\", or \"ROWWISE\".</li> <li><code>design</code> (object): Cannot contain additional properties.</li> <li><code>max_eft</code> (number, format: Centigrade, required): Maximum heat pump entering fluid temperature.</li> <li><code>min_eft</code> (number, format: Centigrade, required): Minimum heat pump entering fluid temperature.</li> <li><code>max_boreholes</code> (number): Maximum number of boreholes in search. Optional. Applies to rectangular and near-square design algorithms. If unspecified, the search space will be bounded by the size of the GHE boundary.</li> <li><code>continue_if_design_unmet</code> (boolean): Causes to return the best available borehole field configuration rather than fail if design conditions are unmet. Optional. Default False. Default: <code>false</code>.</li> <li><code>max_height</code> (number, format: Meters, required): Maximum height, or active length, of each borehole heat exchanger. Minimum: <code>0</code>.</li> <li><code>min_height</code> (number, format: Meters, required): Minimum height, or active length, of each borehole heat exchanger. Minimum: <code>0</code>.</li> <li><code>loads</code>: Refer to #/$defs/loads.</li> </ul> </li> <li><code>simulation_control</code> (object): . Cannot contain additional properties.</li> <li><code>sizing_run</code> (boolean): Field enables or disables running sizing calculations.</li> <li><code>hourly_run</code> (boolean): Field enables running hour simulation.</li> <li><code>sizing_months</code> (number, format: Months, required): Number of months used in ground heat exchanger sizing. Minimum: <code>1</code>.</li> <li><code>timestep</code> (string): This field is currently unused. Simulation timestep used in ground heat exchanger sizing. 'HYBRID' is the only option currently available. Must be one of: \"HYBRID\" or \"HOURLY\". Default: <code>\"HYBRID\"</code>.</li> <li><code>version</code> (integer, required): An integer version ID for this input structure, for future-proofing.</li> </ul>"},{"location":"schema/ghedesigner.schema/#definitions","title":"Definitions","text":"<ul> <li><code>b_max</code> (number, format: Meters): Maximum borehole-to-borehole spacing. Minimum: <code>0</code>.</li> <li><code>b_max_x</code> (number, format: Meters): Maximum borehole-to-borehole spacing in x-direction. Minimum: <code>0</code>.</li> <li><code>b_max_y</code> (number, format: Meters): Maximum borehole-to-borehole spacing in y-direction. Minimum: <code>0</code>.</li> <li><code>b_min</code> (number, format: Meters): Minimum borehole-to-borehole spacing. Minimum: <code>0</code>.</li> <li><code>column</code> (string or integer)</li> <li><code>conductivity</code> (number, format: Watts/Meter-Kelvin): Thermal conductivity. Minimum: <code>0</code>.</li> <li><code>file_path</code> (string)</li> <li><code>H</code> (number, format: Meters): Length of each borehole. Minimum: <code>0</code>.</li> <li><code>inner_diameter</code> (number, format: Meters): Inner diameter of pipe. Minimum: <code>0</code>.</li> <li><code>length</code> (number, format: Meters): Horizontal length of property boundary defining surface area available for ground heat exchanger. Minimum: <code>0</code>.</li> <li><code>load_values</code> (array, format: Watts): Annual, hourly loads of the object. Positive value indicate heating/heat extraction, negative values indicate cooling/heat rejection. Length must be equal to 8760.</li> <li>Items (number)</li> <li><code>loads</code> (object): Cannot contain additional properties.</li> <li>One of<ul> <li>: Cannot contain additional properties.</li> <li><code>load_values</code> (required): Refer to #/$defs/load_values.</li> <li>: Cannot contain additional properties.</li> <li><code>column</code> (required): Refer to #/$defs/column.</li> <li><code>file_path</code> (required): Refer to #/$defs/file_path.</li> </ul> </li> <li><code>column</code>: Refer to #/$defs/column.</li> <li><code>file_path</code>: Refer to #/$defs/file_path.</li> <li><code>load_values</code>: Refer to #/$defs/load_values.</li> <li><code>no_go_boundaries</code> (array, format: Meters): (x, y) coordinate points of closed polygon defining go/no-go boundaries. Go/no-go zones must lie within the area defined in 'property_boundary'. Points should be entered in a counter-clockwise fashion.</li> <li>Items (array)<ul> <li>Items (array): Length must be equal to 2.</li> <li>Items (number): Minimum: <code>0</code>.</li> </ul> </li> <li><code>outer_diameter</code> (number, format: Meters): Outer diameter of pipe. Minimum: <code>0</code>.</li> <li><code>property_boundary</code> (array, format: Meters): (x, y) coordinate points of closed polygon defining property boundary. Points should be entered in a counter-clockwise fashion.</li> <li>Items (array): Length must be equal to 2.<ul> <li>Items (number): Minimum: <code>0</code>.</li> </ul> </li> <li><code>rho_cp</code> (number, format: Joules/Meter^3-Kelvin): Volumetric heat capacity. Minimum: <code>0</code>.</li> <li><code>roughness</code> (number, format: Meters): Surface roughness of pipe. Minimum: <code>0</code>.</li> <li><code>shank_spacing</code> (number, format: Meters): Spacing between up/down legs of u-tube pipe, as measured from nearest outer surfaces of each pipe (o&lt;-- s --&gt;o). Minimum: <code>0</code>.</li> <li><code>width</code> (number, format: Meters): Horizontal width of property boundary defining surface area available for ground heat exchanger. Minimum: <code>0</code>.</li> </ul>"}]}