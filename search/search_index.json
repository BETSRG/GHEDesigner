{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"GHEDesigner - A Flexible and Automatic Ground Heat Exchanger Design Tool","text":""},{"location":"#introduction","title":"Introduction","text":"<p>GHEDesigner is a Python package for designing ground heat exchangers (GHE) used with ground source heat pump (GSHP) systems. Compared to currently available tools such as GLHEPRO, GHEDesigner:</p> <ul> <li>is flexible. It can synthesize borehole fields that are custom fit to the user's property description,</li> <li>implements the RowWise algorithm (Spitler, et al. 2022a) for   automatically placing and sizing boreholes in any land area with complex geometry,</li> <li>is highly automated. It can select library configurations or custom configurations and determine the final number and   depth requirement of boreholes,</li> <li>can make automated conversion of hourly loads to an improved hybrid time step   representation (Cullin and Spitler 2011), and</li> <li>is under continuing development at Oklahoma State University (OSU), Oak Ridge National Laboratory (ORNL), and the   National Renewable Energy Laboratory (NREL). (GLHEPRO remains under development at OSU.)</li> </ul>"},{"location":"#background","title":"Background","text":"<p>GHEDesigner was originally funded through US Department of Energy contract DE\u2010AC05\u201000OR22725 via a subcontract from Oak Ridge National Laboratory. The project led by Dr. Xiaobing Liu developed an online screening tool (Liu, et al. 2022) for techno-economic analysis and design of ground-source heat pump systems. The Oklahoma State University team led by Prof. Jeffrey D. Spitler was contracted to investigate fast methods for computing g-functions. An outgrowth of this research was a tool for automatically selecting and sizing borehole configurations. This tool, originally called GHEDT, is described in an MS thesis (Cook 2021). Since that time, the tool has been renamed GHEDesigner, and work has continued at Oklahoma State University, Oak Ridge National Laboratory, and the National Renewable Energy Laboratory.</p> <p>Updates since Cook (2021) include:</p> <ul> <li>Development and addition of RowWise algorithm to efficiently place boreholes in the available land area.</li> <li>Extensive refactoring for creating a user-focused, stable API.</li> <li>Simplification of library dependencies.</li> <li>Development of automated testing and deployment procedures.</li> </ul>"},{"location":"#borehole-field-design-algorithms","title":"Borehole Field Design Algorithms","text":"<ul> <li>Long time-step g-functions are calculated using pygfunction (Cimmino 2018) using the equivalent borehole   method (Prieto and Cimmino 2021). It's also possible to read   g-functions from a library (Spitler, et al. 2021).</li> <li>Borehole thermal resistance is computed for single and double U-tube configurations via the multipole   method (Claesson and Hellstr\u00f6m 2011). For coaxial ground heat   exchangers, it is computed from fundamental heat transfer relationships.</li> <li>Short time-step g-functions are computed using the   Xu and Spitler (2006) method.</li> <li>GHEDesigner contains a novel design methodology for automated selection of borehole fields. The advanced methodology   performs optimization based on a target drilling depth. An integer bisection routine is utilized to quickly search   over a uni-modal domain of boreholes. GHEDesigner can consider the available land area for drilling and no-drilling   zones defined as polygons.</li> <li>GHEDesigner can synthesize a range of regularly shaped borehole configurations, including previously available   shapes (rectangles, open rectangles, L-shape, U-shape, line) and shapes not previously available (C-shapes and zoned   rectangles). More information about these shapes can be found in the documentation for a publicly available g-function   library. (Spitler, et al. 2021, \\   2022b)</li> <li>GHEDesigner can synthesize on the fly irregularly shaped borehole configurations using the RowWise   algorithm (Spitler, et al. 2022a) or the bi-uniform polygonal constrained   rectangular search (BUPCRS) (Cook 2021). Both configurations are adapted to the   user-specified property boundaries and no-drill zones, if any. Spitler, et al. 2022a   gives an example where the RowWise algorithm saves 12-18% compared to the BUPCRS algorithm. The RowWise algorithm takes   longer to run, though.</li> <li>A set of search routines can be used to size different types of configurations:<ul> <li>The unconstrained square/near-square search will search a domain of square (n x n) and near-square   (n-1 x n) boreholes fields, with uniform spacing between the boreholes.</li> <li>Uniform and bi-uniform constrained rectangular searches will search domains of rectangular configurations that   have either uniform spacing or \"bi-uniform\" spacing \u2013 that is, uniform in the x direction and uniform in the y   direction, but the two spacings may be different.</li> <li>The bi-uniform constrained zoned rectangular search allows for rectangular configurations with different interior   and perimeter spacings.</li> <li>The bi-uniform polygonal constrained rectangular search (BUPCRS) can search configurations with an outer perimeter   and no-go zones described as irregular polygons. This is still referred to as a rectangular search because it is   still based on a rectangular grid, from which boreholes that are outside the perimeter or inside a no-go zone are   removed.</li> <li>The RowWise method generates and searches custom borehole fields that make full use of the available property. The   RowWise algorithms are described by Spitler et al. (2022a).</li> </ul> </li> </ul>"},{"location":"#limitations","title":"Limitations","text":"<p>GHEDesigner does not have every feature that is found in a tool like GLHEPRO. Features that are currently missing include:</p> <ul> <li>Heat pumps are not modeled. Users input heat rejection/extraction rates.</li> <li>An hourly simulation is available, but it doesn't make use of load aggregation, so is very slow.</li> <li>GHEDesigner only covers vertical borehole ground heat exchangers. Horizontal ground heat exchangers are not treated.</li> <li>GHEDesigner does not calculate the head loss in the ground heat exchanger or warn the user that head loss may be   excessive.</li> <li>GHEDesigner does not have a graphical user interface.</li> <li>GHEDesigner is a Python package and requires some Python knowledge to use.</li> </ul>"},{"location":"#requirements","title":"Requirements","text":"<p>GHEDesigner is supported for Python versions &gt;= 3.9, and is tested with Python 3.9-3.12. GHEDesigner is dependent on the following packages:</p> <ul> <li>click (~=8.1)</li> <li>jsonschema (~=4.19)</li> <li>numpy (~=1.26)</li> <li>pygfunction (~=2.2)</li> <li>scipy (~=1.13)</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<p>Users - Install <code>GHEDesigner</code> via the package installer for Python (pip):</p> <pre><code>pip install ghedesigner\n</code></pre> <p>Run a demo file using GHEDesigner:</p> <pre><code>ghedesigner demos/find_design_rectangle_single_u_tube.json ./tmp\n</code></pre> <p>Developers - Clone the repository via git:</p> <pre><code>git clone https://github.com/betsrg/ghedesigner\n</code></pre> <ul> <li>Uv is used to manage the project &amp; dependencies (and may be used to manage Python if you want). After cloning, ensure you have uv installed, then run <code>uv sync</code> to install the package and all development dependencies.<ul> <li>Some Windows developers have reported version conflicts using the default strategy. If this occurs, consider changing the resolution strategy using <code>uv sync --resolution=lowest-direct</code></li> </ul> </li> <li>Developers can then call <code>uv run pytest</code> (which may take 10-30 minutes to run the full test suite) to confirm all dev dependencies have been installed and everything is working as expected.</li> <li>Activate pre-commit (only required once, after cloning the repo) with: <code>uv run pre-commit install</code>. On your first commit it will install the pre-commit environments, then run pre-commit hooks at every commit.</li> <li>Before pushing to Github, run pre-commit on all files with <code>uv run pre-commit run -a</code> to highlight any linting/formatting errors that will cause CI to fail.</li> <li>Pycharm users may need to add Ruff as a 3rd-party plugin or install it as an external tool to their IDE to ensure linting &amp; formatting is consistent.</li> <li>Developers can test in-process functionality by prepending <code>uv run</code> to a command. For instance, to locally replicate one of the CI checks: <code>uv run ghedesigner demos/find_design_rectangle_single_u_tube.json ./tmp</code></li> </ul>"},{"location":"#updating-documentation","title":"Updating documentation","text":"<p>During development we can serve docs locally and view updates with every save.</p> <ol> <li>Start a documentation update branch: <code>git checkout -b &lt;branch_name&gt;</code></li> <li><code>uv run mkdocs serve</code></li> <li>Point browser to http://127.0.0.1:8000/</li> </ol>"},{"location":"#questions","title":"Questions","text":"<p>If there are any questions, comments or concerns please create an issue, comment on an open issue, comment on a closed issue.</p>"},{"location":"#acknowledgements","title":"Acknowledgements","text":"<p>The initial release of this work was financially supported by the U.S. Department of Energy through research subcontracts from Oak Ridge National Laboratory and the National Renewable Energy Laboratory, and by OSU through the Center for Integrated Building Systems, the OG&amp;E Energy Technology Chair, and Oklahoma State University via return of indirect costs to Dr. Jeffrey D. Spitler.</p>"},{"location":"#references","title":"References","text":"<ul> <li> <p>Cimmino, M. 2018. pygfunction: an open-source toolbox for the evaluation of thermal. eSim 2018, Montre\u00e1l, IBPSA Canada. 492-501. http://www.ibpsa.org/proceedings/eSimPapers/2018/2-3-A-4.pdf</p> </li> <li> <p>Claesson, J. and G. Hellstr\u00f6m. 2011. Multipole method to calculate borehole thermal resistances in a borehole heat exchanger. HVAC&amp;R Research 17(6): 895-911. https://doi.org/10.1080/10789669.2011.609927</p> </li> <li> <p>Cook, J.C. (2021). Development of Computer Programs for Fast Computation of g-Functions and Automated Ground Heat Exchanger Design. Master's Thesis, Oklahoma State University, Stillwater, OK. https://hdl.handle.net/11244/335489</p> </li> <li> <p>Cullin, J.R. and J.D. Spitler. 2011. A Computationally Efficient Hybrid Time Step Methodology for Simulation of Ground Heat Exchangers. Geothermics. 40(2): 144-156. https://doi.org/10.1016/j.geothermics.2011.01.001</p> </li> <li> <p>Liu X., J. Degraw, M. Malhotra, W. Forman, M. Adams, G. Accawi, B. Brass, N. Kunwar, J. New, J. Guo. 2022. Development of a Web-based Screening Tool for Ground Source Heat Pump Applications. 2022. IGSHPA Research Conference Proceedings. Pp. 280-290. December 6-8. Las Vegas. http://dx.doi.org/10.22488/okstate.22.000042</p> </li> <li> <p>Prieto, C. and M. Cimmino. 2021. Thermal interactions in large irregular fields of geothermal boreholes: the method of equivalent boreholes. Journal of Building Performance Simulation 14(4): 446-460. https://doi.org/10.1080/19401493.2021.1968953</p> </li> <li> <p>Spitler, J. D., J. Cook, T. West and X. Liu 2021. G-Function Library for Modeling Vertical Bore Ground Heat Exchanger, Oak Ridge National Laboratory. https://doi.org/10.15121/1811518</p> </li> <li> <p>Spitler, J.D., T.N. West and X. Liu. 2022a. Ground Heat Exchanger Design Tool with RowWise Placement of Boreholes. IGSHPA Research Conference Proceedings. Pp. 53-60. Las Vegas. Dec. 6-8. https://doi.org/10.22488/okstate.22.000016</p> </li> <li> <p>Spitler, J.D., T.N. West, X. Liu and I. Borshon. 2022b. An open library of g-functions for 34,321 configurations. IGSHPA Research Conference Proceedings. Pp. 264-271. Las Vegas. Dec. 6-8  https://doi.org/10.22488/okstate.22.000040</p> </li> <li> <p>Xu, X. and J. D. Spitler. 2006. Modelling of Vertical Ground Loop Heat Exchangers with Variable Convective Resistance and Thermal Mass of the Fluid. 10th International Conference on Thermal Energy Storage - Ecostock 2006, Pomona, NJ. https://hvac.okstate.edu/sites/default/files/pubs/papers/2006/07-Xu_Spitler_06.pdf</p> </li> </ul>"},{"location":"cli/","title":"Command Line Interface","text":"<p>This library comes with a command line interface. Once this library is pip installed, a new binary executable will be available with the name <code>ghedesigner</code>. The command has a help argument with output similar to this (execute manually to verify latest syntax):</p> <pre><code>  $ ghedesigner --help\n  Usage: ghedesigner [OPTIONS] INPUT_PATH [OUTPUT_DIRECTORY]\n\n  Options:\n    --version           Show the version and exit.\n    --validate-only     Validate input file and exit.\n    -c, --convert TEXT  Convert output to specified format. Options supported:\n                        'IDF'.\n    --help              Show this message and exit.\n</code></pre>"},{"location":"examples/","title":"Examples","text":""},{"location":"examples/#api-example-usage","title":"API Example Usage","text":"<p>A basic programmatic example is shown below. Additional examples are found at https://github.com/BETSRG/GHEDesigner/tree/main/ghedesigner/tests</p> <pre><code>ghe = GHEManager()\nghe.set_single_u_tube_pipe(\n    inner_diameter=0.03404,\n    outer_diameter=0.04216,\n    shank_spacing=0.01856,\n    roughness=1.0e-6,\n    conductivity=0.4,\n    rho_cp=1542000.0,\n)\nghe.set_soil(conductivity=2.0, rho_cp=2343493.0, undisturbed_temp=18.3)\nghe.set_grout(conductivity=1.0, rho_cp=3901000.0)\nghe.set_fluid()\nghe.set_borehole(height=96.0, buried_depth=2.0, diameter=0.140)\nghe.set_simulation_parameters(num_months=240, max_eft=35, min_eft=5, max_height=135, min_height=60)\nghe.set_ground_loads_from_hourly_list(self.get_atlanta_loads())\nghe.set_geometry_constraints_rectangle(length=85.0, width=36.5, b_min=3.0, b_max=10.0)\nghe.set_design(flow_rate=0.5, flow_type_str=\"borehole\")\nghe.find_design()\n</code></pre>"},{"location":"examples/#command-line-example-usage","title":"Command Line Example Usage","text":"<p>A basic command line example is shown below. Demo files can be found at https://github.com/BETSRG/GHEDesigner/tree/main/demos</p> <pre><code>  $ ghedesigner path/to/my_file.json path/to/output_dir/\n</code></pre>"},{"location":"manager/","title":"Design Manager","text":""},{"location":"manager/#full-documentation-of-the-ghemanager-class","title":"Full documentation of the GHEManager class","text":"Source code in <code>ghedesigner/manager.py</code> <pre><code>class GHEManager:\n    def __init__(self):\n        self._fluid: GHEFluid | None = None\n        self._grout: Grout | None = None\n        self._soil: Soil | None = None\n        self._pipe: Pipe | None = None\n        self.pipe_type: BHPipeType | None = None\n        self._borehole: GHEBorehole | None = None\n        self._simulation_parameters: SimulationParameters | None = None\n        self._ground_loads: list[float | None] = None\n        # OK so geometric_constraints is tricky.  We have base classes, yay!\n        # Unfortunately, the functionality between the child classes is not actually\n        # collapsed into a base class function ... yet.  So there will be complaints\n        # about types temporarily.  It's going in the right direction though.\n        self.geom_type: DesignGeomType | None = None\n        self._geometric_constraints: GeometricConstraints | None = None\n        self._design: DesignBase | None = None\n        self._search: AnyBisectionType | None = None\n        self.results: OutputManager | None = None\n\n        # some things for results\n        self._search_time: int = 0\n        self.summary_results: dict = {}\n\n    def set_design_geometry_type(self, design_geometry_str: str, throw: bool = True) -&gt; int:\n        \"\"\"\n        Sets the design type.\n\n        :param design_geometry_str: design geometry input string.\n        :param throw: By default, function will raise an exception on error, override to false to not raise exception\n        :returns: Zero if successful, nonzero if failure\n        :rtype: int\n        \"\"\"\n        design_geometry_str = str(design_geometry_str).upper()\n        if design_geometry_str == DesignGeomType.BIRECTANGLE.name:\n            self.geom_type = DesignGeomType.BIRECTANGLE\n        elif design_geometry_str == DesignGeomType.BIRECTANGLECONSTRAINED.name:\n            self.geom_type = DesignGeomType.BIRECTANGLECONSTRAINED\n        elif design_geometry_str == DesignGeomType.BIZONEDRECTANGLE.name:\n            self.geom_type = DesignGeomType.BIZONEDRECTANGLE\n        elif design_geometry_str == DesignGeomType.NEARSQUARE.name:\n            self.geom_type = DesignGeomType.NEARSQUARE\n        elif design_geometry_str == DesignGeomType.RECTANGLE.name:\n            self.geom_type = DesignGeomType.RECTANGLE\n        elif design_geometry_str == DesignGeomType.ROWWISE.name:\n            self.geom_type = DesignGeomType.ROWWISE\n        else:\n            message = \"Geometry constraint method not supported.\"\n            print(message, file=stderr)\n            if throw:\n                raise ValueError(message)\n            return 1\n\n        return 0\n\n    def set_pipe_type(self, bh_pipe_str: str, throw: bool = True) -&gt; int:\n        \"\"\"\n        Sets the borehole pipe type.\n\n        :param bh_pipe_str: pipe type input string.\n        :param throw: By default, function will raise an exception on error, override to false to not raise exception\n        :returns: Zero if successful, nonzero if failure\n        :rtype: int\n        \"\"\"\n        bh_pipe_str = str(bh_pipe_str).upper()\n        if bh_pipe_str == BHPipeType.SINGLEUTUBE.name:\n            self.pipe_type = BHPipeType.SINGLEUTUBE\n        elif bh_pipe_str == BHPipeType.DOUBLEUTUBEPARALLEL.name:\n            self.pipe_type = BHPipeType.DOUBLEUTUBEPARALLEL\n        elif bh_pipe_str == BHPipeType.DOUBLEUTUBESERIES.name:\n            self.pipe_type = BHPipeType.DOUBLEUTUBESERIES\n        elif bh_pipe_str == BHPipeType.COAXIAL.name:\n            self.pipe_type = BHPipeType.COAXIAL\n        else:\n            message = f\"Borehole pipe type \\\"{bh_pipe_str}\\\" not supported.\"\n            print(message, file=stderr)\n            if throw:\n                raise ValueError(message)\n            return 1\n\n        return 0\n\n    def set_fluid(\n        self,\n        fluid_name: str = \"Water\",\n        concentration_percent: float = 0.0,\n        temperature: float = 20.0,\n        throw: bool = True,\n    ) -&gt; int:\n        \"\"\"\n        Sets the fluid instance.\n\n        :param fluid_name: fluid name input string.\n        :param concentration_percent: concentration percent of antifreeze mixture.\n        :param temperature: design fluid temperature, in C.\n        :param throw: By default, function will raise an exception on error, override to false to not raise exception\n        :returns: Zero if successful, nonzero if failure\n        :rtype: int\n        \"\"\"\n        try:\n            self._fluid = GHEFluid(fluid_str=fluid_name, percent=concentration_percent, temperature=temperature)\n            return 0\n        except ValueError:\n            message = \"Invalid fluid property input data.\"\n            print(message, file=stderr)\n            if throw:\n                raise ValueError(message)\n            return 1\n\n    def set_grout(self, conductivity: float, rho_cp: float) -&gt; int:\n        \"\"\"\n        Sets the grout instance.\n\n        :param conductivity: thermal conductivity, in W/m-K.\n        :param rho_cp: volumetric heat capacity, in J/m^3-K.\n        :returns: Zero if successful, nonzero if failure\n        :rtype: int\n        \"\"\"\n        self._grout = Grout(conductivity, rho_cp)\n        return 0\n\n    def set_soil(self, conductivity: float, rho_cp: float, undisturbed_temp: float) -&gt; int:\n        \"\"\"\n        Sets the soil instance.\n\n        :param conductivity: thermal conductivity, in W/m-K.\n        :param rho_cp: volumetric heat capacity, in J/m^3-K.\n        :param undisturbed_temp: undisturbed soil temperature, in C.\n        :returns: Zero if successful, nonzero if failure\n        :rtype: int\n        \"\"\"\n        self._soil = Soil(conductivity, rho_cp, undisturbed_temp)\n        return 0\n\n    def set_single_u_tube_pipe(\n        self,\n        inner_diameter: float,\n        outer_diameter: float,\n        shank_spacing: float,\n        roughness: float,\n        conductivity: float,\n        rho_cp: float,\n    ) -&gt; int:\n        \"\"\"\n        Sets the pipe instance for a single u-tube pipe.\n\n        :param inner_diameter: inner pipe diameter, in m.\n        :param outer_diameter: outer pipe diameter, in m.\n        :param shank_spacing: shank spacing between the u-tube legs, in m, as measured edge-to-edge.\n        :param roughness: pipe surface roughness, in m.\n        :param conductivity: thermal conductivity, in W/m-K.\n        :param rho_cp: volumetric heat capacity, in J/m^3-K.\n        :returns: Zero if successful, nonzero if failure\n        :rtype: int\n        \"\"\"\n\n        r_in = inner_diameter / 2.0\n        r_out = outer_diameter / 2.0\n\n        self.pipe_type = BHPipeType.SINGLEUTUBE\n        pipe_positions = Pipe.place_pipes(shank_spacing, r_out, 1)\n        self._pipe = Pipe(pipe_positions, r_in, r_out, shank_spacing, roughness, conductivity, rho_cp)\n        return 0\n\n    def set_double_u_tube_pipe_parallel(\n        self,\n        inner_diameter: float,\n        outer_diameter: float,\n        shank_spacing: float,\n        roughness: float,\n        conductivity: float,\n        rho_cp: float,\n    ) -&gt; int:\n        \"\"\"\n        Sets the pipe instance for a double u-tube pipe in a parallel configuration.\n\n        :param inner_diameter: inner pipe diameter, in m.\n        :param outer_diameter: outer pipe diameter, in m.\n        :param shank_spacing: shank spacing between the u-tube legs, in m, as measured edge-to-edge.\n        :param roughness: pipe surface roughness, in m.\n        :param conductivity: thermal conductivity, in W/m-K.\n        :param rho_cp: volumetric heat capacity, in J/m^3-K.\n        :returns: Zero if successful, nonzero if failure\n        :rtype: int\n        \"\"\"\n\n        r_in = inner_diameter / 2.0\n        r_out = outer_diameter / 2.0\n\n        self.pipe_type = BHPipeType.DOUBLEUTUBEPARALLEL\n        pipe_positions = Pipe.place_pipes(shank_spacing, r_out, 2)\n        self._pipe = Pipe(pipe_positions, r_in, r_out, shank_spacing, roughness, conductivity, rho_cp)\n        return 0\n\n    def set_double_u_tube_pipe_series(\n        self,\n        inner_diameter: float,\n        outer_diameter: float,\n        shank_spacing: float,\n        roughness: float,\n        conductivity: float,\n        rho_cp: float,\n    ) -&gt; int:\n        \"\"\"\n        Sets the pipe instance for a double u-tube pipe in a series configuration.\n\n        :param inner_diameter: inner pipe diameter, in m.\n        :param outer_diameter: outer pipe diameter, in m.\n        :param shank_spacing: shank spacing between the u-tube legs, in m, as measured edge-to-edge.\n        :param roughness: pipe surface roughness, in m.\n        :param conductivity: thermal conductivity, in W/m-K.\n        :param rho_cp: volumetric heat capacity, in J/m^3-K.\n        :returns: Zero if successful, nonzero if failure\n        :rtype: int\n        \"\"\"\n\n        r_in = inner_diameter / 2.0\n        r_out = outer_diameter / 2.0\n\n        self.pipe_type = BHPipeType.DOUBLEUTUBESERIES\n        pipe_positions = Pipe.place_pipes(shank_spacing, r_out, 2)\n        self._pipe = Pipe(pipe_positions, r_in, r_out, shank_spacing, roughness, conductivity, rho_cp)\n        return 0\n\n    def set_coaxial_pipe(\n        self,\n        inner_pipe_d_in: float,\n        inner_pipe_d_out: float,\n        outer_pipe_d_in: float,\n        outer_pipe_d_out: float,\n        roughness: float,\n        conductivity_inner: float,\n        conductivity_outer: float,\n        rho_cp: float,\n    ) -&gt; int:\n        \"\"\"\n        Sets the pipe instance for a coaxial pipe.\n\n        :param inner_pipe_d_in: inner pipe inner diameter, in m.\n        :param inner_pipe_d_out: inner pipe outer diameter, in m.\n        :param outer_pipe_d_in: outer pipe inner diameter, in m.\n        :param outer_pipe_d_out: outer pipe outer diameter, in m.\n        :param roughness: pipe surface roughness, in m.\n        :param conductivity_inner: thermal conductivity of inner pipe, in W/m-K.\n        :param conductivity_outer: thermal conductivity of outer pipe, in W/m-K.\n        :param rho_cp: volumetric heat capacity, in J/m^3-K.\n        :returns: Zero if successful, nonzero if failure\n        :rtype: int\n        \"\"\"\n\n        self.pipe_type = BHPipeType.COAXIAL\n\n        # Note: This convention is different from pygfunction\n        r_inner = [inner_pipe_d_in / 2.0, inner_pipe_d_out / 2.0]  # The radii of the inner pipe from in to out\n        r_outer = [outer_pipe_d_in / 2.0, outer_pipe_d_out / 2.0]  # The radii of the outer pipe from in to out\n        k_p = [conductivity_inner, conductivity_outer]\n        self._pipe = Pipe((0, 0), r_inner, r_outer, 0, roughness, k_p, rho_cp)\n        return 0\n\n    def set_borehole(self, height: float, buried_depth: float, diameter: float) -&gt; int:\n        \"\"\"\n        Sets the borehole instance\n\n        :param height: height, or active length, of the borehole, in m.\n        :param buried_depth: depth of top of borehole below the ground surface, in m.\n        :param diameter: diameter of the borehole, in m.\n        :returns: Zero if successful, nonzero if failure\n        :rtype: int\n        \"\"\"\n        radius = diameter / 2.0\n        self._borehole = GHEBorehole(height, buried_depth, radius, x=0.0, y=0.0)\n        return 0\n\n    def set_simulation_parameters(\n        self,\n        num_months: int,\n        max_eft: float,\n        min_eft: float,\n        max_height: float,\n        min_height: float,\n        max_boreholes: int | None = None,\n        continue_if_design_unmet: bool = False,\n    ) -&gt; int:\n        \"\"\"\n        Sets the simulation parameters\n\n        :param num_months: number of months in simulation.\n        :param max_eft: maximum heat pump entering fluid temperature, in C.\n        :param min_eft: minimum heat pump entering fluid temperature, in C.\n        :param max_height: maximum height of borehole, in m.\n        :param min_height: minimum height of borehole, in m.\n        :param max_boreholes: maximum boreholes in search algorithms.\n        :param continue_if_design_unmet: continues to process if design unmet.\n        :returns: Zero if successful, nonzero if failure\n        :rtype: int\n        \"\"\"\n        self._simulation_parameters = SimulationParameters(\n            1, num_months, max_eft, min_eft, max_height, min_height, max_boreholes, continue_if_design_unmet\n        )\n        return 0\n\n    def set_ground_loads_from_hourly_list(self, hourly_ground_loads: list[float]) -&gt; int:\n        \"\"\"\n        Sets the ground loads based on a list input.\n\n        :param hourly_ground_loads: annual, hourly ground loads, in W.\n         positive values indicate heat extraction, negative values indicate heat rejection.\n        :returns: Zero if successful, nonzero if failure\n        :rtype: int\n        \"\"\"\n        # TODO: Add API methods for different load inputs\n        self._ground_loads = hourly_ground_loads\n        return 0\n\n    def set_geometry_constraints_near_square(self, b: float, length: float) -&gt; int:\n        \"\"\"\n        Sets the geometry constraints for the near-square design method.\n\n        :param b: borehole-to-borehole spacing, in m.\n        :param length: side length of the sizing domain, in m.\n        :returns: Zero if successful, nonzero if failure\n        :rtype: int\n        \"\"\"\n        self._geometric_constraints = GeometricConstraintsNearSquare(b, length)\n        return 0\n\n    def set_geometry_constraints_rectangle(self, length: float, width: float, b_min: float, b_max: float) -&gt; int:\n        \"\"\"\n        Sets the geometry constraints for the rectangle design method.\n\n        :param length: side length of the sizing domain, in m.\n        :param width: side width of the sizing domain, in m.\n        :param b_min: minimum borehole-to-borehole spacing, in m.\n        :param b_max: maximum borehole-to-borehole spacing, in m.\n        :returns: Zero if successful, nonzero if failure\n        :rtype: int\n        \"\"\"\n        self.geom_type = DesignGeomType.RECTANGLE\n        self._geometric_constraints = GeometricConstraintsRectangle(width, length, b_min, b_max)\n        return 0\n\n    def set_geometry_constraints_bi_rectangle(\n        self, length: float, width: float, b_min: float, b_max_x: float, b_max_y: float\n    ) -&gt; int:\n        \"\"\"\n        Sets the geometry constraints for the bi-rectangle design method.\n\n        :param length: side length of the sizing domain, in m.\n        :param width: side width of the sizing domain, in m.\n        :param b_min: minimum borehole-to-borehole spacing, in m.\n        :param b_max_x: maximum borehole-to-borehole spacing in the x-direction, in m.\n        :param b_max_y: maximum borehole-to-borehole spacing in the y-direction, in m.\n        :returns: Zero if successful, nonzero if failure\n        :rtype: int\n        \"\"\"\n        self.geom_type = DesignGeomType.BIRECTANGLE\n        self._geometric_constraints = GeometricConstraintsBiRectangle(width, length, b_min, b_max_x, b_max_y)\n        return 0\n\n    def set_geometry_constraints_bi_zoned_rectangle(\n        self, length: float, width: float, b_min: float, b_max_x: float, b_max_y: float\n    ) -&gt; int:\n        \"\"\"\n        Sets the geometry constraints for the bi-zoned rectangle design method.\n\n        :param length: side length of the sizing domain, in m.\n        :param width: side width of the sizing domain, in m.\n        :param b_min: minimum borehole-to-borehole spacing, in m.\n        :param b_max_x: maximum borehole-to-borehole spacing in the x-direction, in m.\n        :param b_max_y: maximum borehole-to-borehole spacing in the y-direction, in m.\n        :returns: Zero if successful, nonzero if failure\n        :rtype: int\n        \"\"\"\n        self.geom_type = DesignGeomType.BIZONEDRECTANGLE\n        self._geometric_constraints = GeometricConstraintsBiZoned(width, length, b_min, b_max_x, b_max_y)\n        return 0\n\n    def set_geometry_constraints_bi_rectangle_constrained(\n        self, b_min: float, b_max_x: float, b_max_y: float, property_boundary: list, no_go_boundaries: list\n    ) -&gt; int:\n        \"\"\"\n        Sets the geometry constraints for the bi-rectangle constrained design method.\n\n        :param b_min: minimum borehole-to-borehole spacing, in m.\n        :param b_max_x: maximum borehole-to-borehole spacing in the x-direction, in m.\n        :param b_max_y: maximum borehole-to-borehole spacing in the y-direction, in m.\n        :param property_boundary: property boundary points, in m.\n        :param no_go_boundaries: boundary points for no-go zones, in m.\n        :returns: Zero if successful, nonzero if failure\n        :rtype: int\n        \"\"\"\n        self.geom_type = DesignGeomType.BIRECTANGLECONSTRAINED\n        self._geometric_constraints = GeometricConstraintsBiRectangleConstrained(\n            b_min, b_max_x, b_max_y, property_boundary, no_go_boundaries\n        )\n        return 0\n\n    def set_geometry_constraints_rowwise(\n        self,\n        perimeter_spacing_ratio: float | None,\n        max_spacing: float,\n        min_spacing: float,\n        spacing_step: float,\n        max_rotation: float,\n        min_rotation: float,\n        rotate_step: float,\n        property_boundary: list,\n        no_go_boundaries: list,\n    ) -&gt; int:\n        \"\"\"\n        Sets the geometry constraints for the row-wise design method.\n\n        :param perimeter_spacing_ratio: the ratio between the minimum spacing between\n            boreholes placed along the property and no-go zones and the standard borehole-to-borehole\n            spacing used for internal boreholes.\n        :param max_spacing: the largest minimum spacing that will be used to generate a RowWise field.\n        :param min_spacing: the smallest minimum spacing that will be used to generate a RowWise field.\n        :param spacing_step: the distance in spacing from the design found in the first part of first\n            search to exhaustively check in the second part.\n        :param max_rotation: the maximum rotation of the rows of each field relative to horizontal that\n            will be used in the search.\n        :param min_rotation: the minimum rotation of the rows of each field relative to horizontal that\n            will be used in the search.\n        :param rotate_step: step size for field rotation search.\n        :param property_boundary: property boundary points.\n        :param no_go_boundaries: boundary points for no-go zones.\n        :returns: Zero if successful, nonzero if failure\n        :rtype: int\n        \"\"\"\n\n        # convert from degrees to radians\n        max_rotation = max_rotation * DEG_TO_RAD\n        min_rotation = min_rotation * DEG_TO_RAD\n\n        self.geom_type = DesignGeomType.ROWWISE\n        self._geometric_constraints = GeometricConstraintsRowWise(\n            perimeter_spacing_ratio,\n            min_spacing,\n            max_spacing,\n            spacing_step,\n            min_rotation,\n            max_rotation,\n            rotate_step,\n            property_boundary,\n            no_go_boundaries,\n        )\n        return 0\n\n    def set_design(self, flow_rate: float, flow_type_str: str, throw: bool = True) -&gt; int:\n        \"\"\"\n        Set the design method.\n\n        :param flow_rate: design flow rate, in lps.\n        :param flow_type_str: flow type string input.\n        :param throw: By default, function will raise an exception on error, override to false to not raise exception\n        :returns: Zero if successful, nonzero if failure\n        :rtype: int\n        \"\"\"\n\n        flow_type_str = flow_type_str.upper()\n        if flow_type_str == FlowConfigType.SYSTEM.name:\n            flow_type = FlowConfigType.SYSTEM\n        elif flow_type_str == FlowConfigType.BOREHOLE.name:\n            flow_type = FlowConfigType.BOREHOLE\n        else:\n            message = f\"FlowConfig \\\"{flow_type_str}\\\" is not implemented.\"\n            print(message, file=stderr)\n            if throw:\n                raise ValueError(message)\n            return 1\n\n        if self._geometric_constraints.type is None:\n            message = \"Geometric constraints must be set before `set_design` is called.\"\n            print(message, file=stderr)\n            if throw:\n                raise ValueError(message)\n            return 1\n\n        if self._geometric_constraints.type == DesignGeomType.NEARSQUARE:\n            # temporary disable of the type checker because of the _geometric_constraints member\n            # noinspection PyTypeChecker\n            self._design = DesignNearSquare(\n                flow_rate,\n                self._borehole,\n                self.pipe_type,\n                self._fluid,\n                self._pipe,\n                self._grout,\n                self._soil,\n                self._simulation_parameters,\n                self._geometric_constraints,\n                self._ground_loads,\n                flow_type=flow_type,\n                method=TimestepType.HYBRID,\n            )\n        elif self._geometric_constraints.type == DesignGeomType.RECTANGLE:\n            # temporary disable of the type checker because of the _geometric_constraints member\n            # noinspection PyTypeChecker\n            self._design = DesignRectangle(\n                flow_rate,\n                self._borehole,\n                self.pipe_type,\n                self._fluid,\n                self._pipe,\n                self._grout,\n                self._soil,\n                self._simulation_parameters,\n                self._geometric_constraints,\n                self._ground_loads,\n                flow_type=flow_type,\n                method=TimestepType.HYBRID,\n            )\n        elif self._geometric_constraints.type == DesignGeomType.BIRECTANGLE:\n            # temporary disable of the type checker because of the _geometric_constraints member\n            # noinspection PyTypeChecker\n            self._design = DesignBiRectangle(\n                flow_rate,\n                self._borehole,\n                self.pipe_type,\n                self._fluid,\n                self._pipe,\n                self._grout,\n                self._soil,\n                self._simulation_parameters,\n                self._geometric_constraints,\n                self._ground_loads,\n                flow_type=flow_type,\n                method=TimestepType.HYBRID,\n            )\n        elif self._geometric_constraints.type == DesignGeomType.BIZONEDRECTANGLE:\n            # temporary disable of the type checker because of the _geometric_constraints member\n            # noinspection PyTypeChecker\n            self._design = DesignBiZoned(\n                flow_rate,\n                self._borehole,\n                self.pipe_type,\n                self._fluid,\n                self._pipe,\n                self._grout,\n                self._soil,\n                self._simulation_parameters,\n                self._geometric_constraints,\n                self._ground_loads,\n                flow_type=flow_type,\n                method=TimestepType.HYBRID,\n            )\n        elif self._geometric_constraints.type == DesignGeomType.BIRECTANGLECONSTRAINED:\n            # temporary disable of the type checker because of the _geometric_constraints member\n            # noinspection PyTypeChecker\n            self._design = DesignBiRectangleConstrained(\n                flow_rate,\n                self._borehole,\n                self.pipe_type,\n                self._fluid,\n                self._pipe,\n                self._grout,\n                self._soil,\n                self._simulation_parameters,\n                self._geometric_constraints,\n                self._ground_loads,\n                flow_type=flow_type,\n                method=TimestepType.HYBRID,\n            )\n        elif self._geometric_constraints.type == DesignGeomType.ROWWISE:\n            # temporary disable of the type checker because of the _geometric_constraints member\n            # noinspection PyTypeChecker\n            self._design = DesignRowWise(\n                flow_rate,\n                self._borehole,\n                self.pipe_type,\n                self._fluid,\n                self._pipe,\n                self._grout,\n                self._soil,\n                self._simulation_parameters,\n                self._geometric_constraints,\n                self._ground_loads,\n                flow_type=flow_type,\n                method=TimestepType.HYBRID,\n            )\n        else:\n            message = \"This design method has not been implemented\"\n            print(message, file=stderr)\n            if throw:\n                raise ValueError(message)\n            return 1\n        return 0\n\n    def find_design(self, throw: bool = True) -&gt; int:\n        \"\"\"\n        Calls design methods to execute sizing.\n\n        :param throw: By default, function will raise an exception on error, override to false to not raise exception\n        :returns: Zero if successful, nonzero if failure\n        :rtype: int\n        \"\"\"\n\n        if not all(\n            [\n                self._fluid,\n                self._grout,\n                self._soil,\n                self._pipe,\n                self._borehole,\n                self._simulation_parameters,\n                self._ground_loads,\n                self._geometric_constraints,\n                self._design,\n            ]\n        ):\n            message = \"All GHE properties must be set before GHEManager.find_design is called.\"\n            print(message, file=stderr)\n            if throw:\n                raise ValueError(message)\n            return 1\n\n        start_time = time()\n        self._search = self._design.find_design()\n        self._search.ghe.compute_g_functions()\n        self._search_time = time() - start_time\n        self._search.ghe.size(method=TimestepType.HYBRID)\n        return 0\n\n    def prepare_results(self, project_name: str, note: str, author: str, iteration_name: str):\n        \"\"\"\n        Prepares the output results.\n        \"\"\"\n        self.results = OutputManager(\n            self._search,\n            self._search_time,\n            project_name,\n            note,\n            author,\n            iteration_name,\n            load_method=TimestepType.HYBRID,\n        )\n\n    def write_output_files(self, output_directory: Path, output_file_suffix: str = \"\"):\n        \"\"\"\n        Writes the output files.\n\n        :param output_directory: output directory for output files.\n        :param output_file_suffix: adds a string suffix to the output files.\n        \"\"\"\n        self.results.write_all_output_files(output_directory=output_directory, file_suffix=output_file_suffix)\n\n    def write_input_file(self, output_file_path: Path, throw: bool = True) -&gt; int:\n        \"\"\"\n        Writes an input file based on current simulation configuration.\n\n        :param output_file_path: output directory to write input file.\n        :param throw: By default, function will raise an exception on error, override to false to not raise exception\n        :returns: Zero if successful, nonzero if failure\n        :rtype: int\n        \"\"\"\n\n        # TODO: geometric constraints are currently held in two places\n        #       SimulationParameters and GeometricConstraints\n        #       these should be consolidated\n        d_geo = self._geometric_constraints.to_input()\n        d_geo['max_height'] = self._simulation_parameters.max_height\n        d_geo['min_height'] = self._simulation_parameters.min_height\n\n        # TODO: data held in different places\n        d_des = self._design.to_input()\n        d_des['max_eft'] = self._simulation_parameters.max_EFT_allowable\n        d_des['min_eft'] = self._simulation_parameters.min_EFT_allowable\n\n        if self._simulation_parameters.max_boreholes is not None:\n            d_des['max_boreholes'] = self._simulation_parameters.max_boreholes\n        if self._simulation_parameters.continue_if_design_unmet is True:\n            d_des['continue_if_design_unmet'] = self._simulation_parameters.continue_if_design_unmet\n\n        # pipe data\n        d_pipe = {'rho_cp': self._pipe.rhoCp, 'roughness': self._pipe.roughness}\n\n        if self.pipe_type in [BHPipeType.SINGLEUTUBE, BHPipeType.DOUBLEUTUBEPARALLEL, BHPipeType.DOUBLEUTUBESERIES]:\n            d_pipe['inner_diameter'] = self._pipe.r_in * 2.0\n            d_pipe['outer_diameter'] = self._pipe.r_out * 2.0\n            d_pipe['shank_spacing'] = self._pipe.s\n            d_pipe['conductivity'] = self._pipe.k\n        elif self.pipe_type == BHPipeType.COAXIAL:\n            d_pipe['inner_pipe_d_in'] = self._pipe.r_in[0] * 2.0\n            d_pipe['inner_pipe_d_out'] = self._pipe.r_in[1] * 2.0\n            d_pipe['outer_pipe_d_in'] = self._pipe.r_out[0] * 2.0\n            d_pipe['outer_pipe_d_out'] = self._pipe.r_out[1] * 2.0\n            d_pipe['conductivity_inner'] = self._pipe.k[0]\n            d_pipe['conductivity_outer'] = self._pipe.k[1]\n        else:\n            message = 'Invalid pipe type'\n            print(message, file=stderr)\n            if throw:\n                raise ValueError(message)\n            return 1\n\n        if self.pipe_type == BHPipeType.SINGLEUTUBE:\n            d_pipe['arrangement'] = BHPipeType.SINGLEUTUBE.name\n        elif self.pipe_type == BHPipeType.DOUBLEUTUBEPARALLEL:\n            d_pipe['arrangement'] = BHPipeType.DOUBLEUTUBEPARALLEL.name\n        elif self.pipe_type == BHPipeType.DOUBLEUTUBESERIES:\n            d_pipe['arrangement'] = BHPipeType.DOUBLEUTUBESERIES.name\n        elif self.pipe_type == BHPipeType.COAXIAL:\n            d_pipe['arrangement'] = BHPipeType.COAXIAL.name\n        else:\n            message = 'Invalid pipe type'\n            print(message, file=stderr)\n            if throw:\n                raise ValueError(message)\n            return 1\n\n        d = {\n            'version': VERSION,\n            'fluid': self._fluid.to_input(),\n            'grout': self._grout.to_input(),\n            'soil': self._soil.to_input(),\n            'pipe': d_pipe,\n            'borehole': self._borehole.to_input(),\n            'simulation': self._simulation_parameters.to_input(),\n            'geometric_constraints': d_geo,\n            'design': d_des,\n            'loads': {'ground_loads': list(self._ground_loads)},\n        }\n\n        with open(output_file_path, 'w') as f:\n            f.write(dumps(d, sort_keys=True, indent=2, separators=(',', ': ')))\n        return 0\n</code></pre>"},{"location":"manager/#ghedesigner.manager.GHEManager.find_design","title":"<code>find_design(throw=True)</code>","text":"<p>Calls design methods to execute sizing.</p> <p>Parameters:</p> Name Type Description Default <code>throw</code> <code>bool</code> <p>By default, function will raise an exception on error, override to false to not raise exception</p> <code>True</code> <p>Returns:</p> Type Description <code>int</code> <p>Zero if successful, nonzero if failure</p> Source code in <code>ghedesigner/manager.py</code> <pre><code>def find_design(self, throw: bool = True) -&gt; int:\n    \"\"\"\n    Calls design methods to execute sizing.\n\n    :param throw: By default, function will raise an exception on error, override to false to not raise exception\n    :returns: Zero if successful, nonzero if failure\n    :rtype: int\n    \"\"\"\n\n    if not all(\n        [\n            self._fluid,\n            self._grout,\n            self._soil,\n            self._pipe,\n            self._borehole,\n            self._simulation_parameters,\n            self._ground_loads,\n            self._geometric_constraints,\n            self._design,\n        ]\n    ):\n        message = \"All GHE properties must be set before GHEManager.find_design is called.\"\n        print(message, file=stderr)\n        if throw:\n            raise ValueError(message)\n        return 1\n\n    start_time = time()\n    self._search = self._design.find_design()\n    self._search.ghe.compute_g_functions()\n    self._search_time = time() - start_time\n    self._search.ghe.size(method=TimestepType.HYBRID)\n    return 0\n</code></pre>"},{"location":"manager/#ghedesigner.manager.GHEManager.prepare_results","title":"<code>prepare_results(project_name, note, author, iteration_name)</code>","text":"<p>Prepares the output results.</p> Source code in <code>ghedesigner/manager.py</code> <pre><code>def prepare_results(self, project_name: str, note: str, author: str, iteration_name: str):\n    \"\"\"\n    Prepares the output results.\n    \"\"\"\n    self.results = OutputManager(\n        self._search,\n        self._search_time,\n        project_name,\n        note,\n        author,\n        iteration_name,\n        load_method=TimestepType.HYBRID,\n    )\n</code></pre>"},{"location":"manager/#ghedesigner.manager.GHEManager.set_borehole","title":"<code>set_borehole(height, buried_depth, diameter)</code>","text":"<p>Sets the borehole instance</p> <p>Parameters:</p> Name Type Description Default <code>height</code> <code>float</code> <p>height, or active length, of the borehole, in m.</p> required <code>buried_depth</code> <code>float</code> <p>depth of top of borehole below the ground surface, in m.</p> required <code>diameter</code> <code>float</code> <p>diameter of the borehole, in m.</p> required <p>Returns:</p> Type Description <code>int</code> <p>Zero if successful, nonzero if failure</p> Source code in <code>ghedesigner/manager.py</code> <pre><code>def set_borehole(self, height: float, buried_depth: float, diameter: float) -&gt; int:\n    \"\"\"\n    Sets the borehole instance\n\n    :param height: height, or active length, of the borehole, in m.\n    :param buried_depth: depth of top of borehole below the ground surface, in m.\n    :param diameter: diameter of the borehole, in m.\n    :returns: Zero if successful, nonzero if failure\n    :rtype: int\n    \"\"\"\n    radius = diameter / 2.0\n    self._borehole = GHEBorehole(height, buried_depth, radius, x=0.0, y=0.0)\n    return 0\n</code></pre>"},{"location":"manager/#ghedesigner.manager.GHEManager.set_coaxial_pipe","title":"<code>set_coaxial_pipe(inner_pipe_d_in, inner_pipe_d_out, outer_pipe_d_in, outer_pipe_d_out, roughness, conductivity_inner, conductivity_outer, rho_cp)</code>","text":"<p>Sets the pipe instance for a coaxial pipe.</p> <p>Parameters:</p> Name Type Description Default <code>inner_pipe_d_in</code> <code>float</code> <p>inner pipe inner diameter, in m.</p> required <code>inner_pipe_d_out</code> <code>float</code> <p>inner pipe outer diameter, in m.</p> required <code>outer_pipe_d_in</code> <code>float</code> <p>outer pipe inner diameter, in m.</p> required <code>outer_pipe_d_out</code> <code>float</code> <p>outer pipe outer diameter, in m.</p> required <code>roughness</code> <code>float</code> <p>pipe surface roughness, in m.</p> required <code>conductivity_inner</code> <code>float</code> <p>thermal conductivity of inner pipe, in W/m-K.</p> required <code>conductivity_outer</code> <code>float</code> <p>thermal conductivity of outer pipe, in W/m-K.</p> required <code>rho_cp</code> <code>float</code> <p>volumetric heat capacity, in J/m^3-K.</p> required <p>Returns:</p> Type Description <code>int</code> <p>Zero if successful, nonzero if failure</p> Source code in <code>ghedesigner/manager.py</code> <pre><code>def set_coaxial_pipe(\n    self,\n    inner_pipe_d_in: float,\n    inner_pipe_d_out: float,\n    outer_pipe_d_in: float,\n    outer_pipe_d_out: float,\n    roughness: float,\n    conductivity_inner: float,\n    conductivity_outer: float,\n    rho_cp: float,\n) -&gt; int:\n    \"\"\"\n    Sets the pipe instance for a coaxial pipe.\n\n    :param inner_pipe_d_in: inner pipe inner diameter, in m.\n    :param inner_pipe_d_out: inner pipe outer diameter, in m.\n    :param outer_pipe_d_in: outer pipe inner diameter, in m.\n    :param outer_pipe_d_out: outer pipe outer diameter, in m.\n    :param roughness: pipe surface roughness, in m.\n    :param conductivity_inner: thermal conductivity of inner pipe, in W/m-K.\n    :param conductivity_outer: thermal conductivity of outer pipe, in W/m-K.\n    :param rho_cp: volumetric heat capacity, in J/m^3-K.\n    :returns: Zero if successful, nonzero if failure\n    :rtype: int\n    \"\"\"\n\n    self.pipe_type = BHPipeType.COAXIAL\n\n    # Note: This convention is different from pygfunction\n    r_inner = [inner_pipe_d_in / 2.0, inner_pipe_d_out / 2.0]  # The radii of the inner pipe from in to out\n    r_outer = [outer_pipe_d_in / 2.0, outer_pipe_d_out / 2.0]  # The radii of the outer pipe from in to out\n    k_p = [conductivity_inner, conductivity_outer]\n    self._pipe = Pipe((0, 0), r_inner, r_outer, 0, roughness, k_p, rho_cp)\n    return 0\n</code></pre>"},{"location":"manager/#ghedesigner.manager.GHEManager.set_design","title":"<code>set_design(flow_rate, flow_type_str, throw=True)</code>","text":"<p>Set the design method.</p> <p>Parameters:</p> Name Type Description Default <code>flow_rate</code> <code>float</code> <p>design flow rate, in lps.</p> required <code>flow_type_str</code> <code>str</code> <p>flow type string input.</p> required <code>throw</code> <code>bool</code> <p>By default, function will raise an exception on error, override to false to not raise exception</p> <code>True</code> <p>Returns:</p> Type Description <code>int</code> <p>Zero if successful, nonzero if failure</p> Source code in <code>ghedesigner/manager.py</code> <pre><code>def set_design(self, flow_rate: float, flow_type_str: str, throw: bool = True) -&gt; int:\n    \"\"\"\n    Set the design method.\n\n    :param flow_rate: design flow rate, in lps.\n    :param flow_type_str: flow type string input.\n    :param throw: By default, function will raise an exception on error, override to false to not raise exception\n    :returns: Zero if successful, nonzero if failure\n    :rtype: int\n    \"\"\"\n\n    flow_type_str = flow_type_str.upper()\n    if flow_type_str == FlowConfigType.SYSTEM.name:\n        flow_type = FlowConfigType.SYSTEM\n    elif flow_type_str == FlowConfigType.BOREHOLE.name:\n        flow_type = FlowConfigType.BOREHOLE\n    else:\n        message = f\"FlowConfig \\\"{flow_type_str}\\\" is not implemented.\"\n        print(message, file=stderr)\n        if throw:\n            raise ValueError(message)\n        return 1\n\n    if self._geometric_constraints.type is None:\n        message = \"Geometric constraints must be set before `set_design` is called.\"\n        print(message, file=stderr)\n        if throw:\n            raise ValueError(message)\n        return 1\n\n    if self._geometric_constraints.type == DesignGeomType.NEARSQUARE:\n        # temporary disable of the type checker because of the _geometric_constraints member\n        # noinspection PyTypeChecker\n        self._design = DesignNearSquare(\n            flow_rate,\n            self._borehole,\n            self.pipe_type,\n            self._fluid,\n            self._pipe,\n            self._grout,\n            self._soil,\n            self._simulation_parameters,\n            self._geometric_constraints,\n            self._ground_loads,\n            flow_type=flow_type,\n            method=TimestepType.HYBRID,\n        )\n    elif self._geometric_constraints.type == DesignGeomType.RECTANGLE:\n        # temporary disable of the type checker because of the _geometric_constraints member\n        # noinspection PyTypeChecker\n        self._design = DesignRectangle(\n            flow_rate,\n            self._borehole,\n            self.pipe_type,\n            self._fluid,\n            self._pipe,\n            self._grout,\n            self._soil,\n            self._simulation_parameters,\n            self._geometric_constraints,\n            self._ground_loads,\n            flow_type=flow_type,\n            method=TimestepType.HYBRID,\n        )\n    elif self._geometric_constraints.type == DesignGeomType.BIRECTANGLE:\n        # temporary disable of the type checker because of the _geometric_constraints member\n        # noinspection PyTypeChecker\n        self._design = DesignBiRectangle(\n            flow_rate,\n            self._borehole,\n            self.pipe_type,\n            self._fluid,\n            self._pipe,\n            self._grout,\n            self._soil,\n            self._simulation_parameters,\n            self._geometric_constraints,\n            self._ground_loads,\n            flow_type=flow_type,\n            method=TimestepType.HYBRID,\n        )\n    elif self._geometric_constraints.type == DesignGeomType.BIZONEDRECTANGLE:\n        # temporary disable of the type checker because of the _geometric_constraints member\n        # noinspection PyTypeChecker\n        self._design = DesignBiZoned(\n            flow_rate,\n            self._borehole,\n            self.pipe_type,\n            self._fluid,\n            self._pipe,\n            self._grout,\n            self._soil,\n            self._simulation_parameters,\n            self._geometric_constraints,\n            self._ground_loads,\n            flow_type=flow_type,\n            method=TimestepType.HYBRID,\n        )\n    elif self._geometric_constraints.type == DesignGeomType.BIRECTANGLECONSTRAINED:\n        # temporary disable of the type checker because of the _geometric_constraints member\n        # noinspection PyTypeChecker\n        self._design = DesignBiRectangleConstrained(\n            flow_rate,\n            self._borehole,\n            self.pipe_type,\n            self._fluid,\n            self._pipe,\n            self._grout,\n            self._soil,\n            self._simulation_parameters,\n            self._geometric_constraints,\n            self._ground_loads,\n            flow_type=flow_type,\n            method=TimestepType.HYBRID,\n        )\n    elif self._geometric_constraints.type == DesignGeomType.ROWWISE:\n        # temporary disable of the type checker because of the _geometric_constraints member\n        # noinspection PyTypeChecker\n        self._design = DesignRowWise(\n            flow_rate,\n            self._borehole,\n            self.pipe_type,\n            self._fluid,\n            self._pipe,\n            self._grout,\n            self._soil,\n            self._simulation_parameters,\n            self._geometric_constraints,\n            self._ground_loads,\n            flow_type=flow_type,\n            method=TimestepType.HYBRID,\n        )\n    else:\n        message = \"This design method has not been implemented\"\n        print(message, file=stderr)\n        if throw:\n            raise ValueError(message)\n        return 1\n    return 0\n</code></pre>"},{"location":"manager/#ghedesigner.manager.GHEManager.set_design_geometry_type","title":"<code>set_design_geometry_type(design_geometry_str, throw=True)</code>","text":"<p>Sets the design type.</p> <p>Parameters:</p> Name Type Description Default <code>design_geometry_str</code> <code>str</code> <p>design geometry input string.</p> required <code>throw</code> <code>bool</code> <p>By default, function will raise an exception on error, override to false to not raise exception</p> <code>True</code> <p>Returns:</p> Type Description <code>int</code> <p>Zero if successful, nonzero if failure</p> Source code in <code>ghedesigner/manager.py</code> <pre><code>def set_design_geometry_type(self, design_geometry_str: str, throw: bool = True) -&gt; int:\n    \"\"\"\n    Sets the design type.\n\n    :param design_geometry_str: design geometry input string.\n    :param throw: By default, function will raise an exception on error, override to false to not raise exception\n    :returns: Zero if successful, nonzero if failure\n    :rtype: int\n    \"\"\"\n    design_geometry_str = str(design_geometry_str).upper()\n    if design_geometry_str == DesignGeomType.BIRECTANGLE.name:\n        self.geom_type = DesignGeomType.BIRECTANGLE\n    elif design_geometry_str == DesignGeomType.BIRECTANGLECONSTRAINED.name:\n        self.geom_type = DesignGeomType.BIRECTANGLECONSTRAINED\n    elif design_geometry_str == DesignGeomType.BIZONEDRECTANGLE.name:\n        self.geom_type = DesignGeomType.BIZONEDRECTANGLE\n    elif design_geometry_str == DesignGeomType.NEARSQUARE.name:\n        self.geom_type = DesignGeomType.NEARSQUARE\n    elif design_geometry_str == DesignGeomType.RECTANGLE.name:\n        self.geom_type = DesignGeomType.RECTANGLE\n    elif design_geometry_str == DesignGeomType.ROWWISE.name:\n        self.geom_type = DesignGeomType.ROWWISE\n    else:\n        message = \"Geometry constraint method not supported.\"\n        print(message, file=stderr)\n        if throw:\n            raise ValueError(message)\n        return 1\n\n    return 0\n</code></pre>"},{"location":"manager/#ghedesigner.manager.GHEManager.set_double_u_tube_pipe_parallel","title":"<code>set_double_u_tube_pipe_parallel(inner_diameter, outer_diameter, shank_spacing, roughness, conductivity, rho_cp)</code>","text":"<p>Sets the pipe instance for a double u-tube pipe in a parallel configuration.</p> <p>Parameters:</p> Name Type Description Default <code>inner_diameter</code> <code>float</code> <p>inner pipe diameter, in m.</p> required <code>outer_diameter</code> <code>float</code> <p>outer pipe diameter, in m.</p> required <code>shank_spacing</code> <code>float</code> <p>shank spacing between the u-tube legs, in m, as measured edge-to-edge.</p> required <code>roughness</code> <code>float</code> <p>pipe surface roughness, in m.</p> required <code>conductivity</code> <code>float</code> <p>thermal conductivity, in W/m-K.</p> required <code>rho_cp</code> <code>float</code> <p>volumetric heat capacity, in J/m^3-K.</p> required <p>Returns:</p> Type Description <code>int</code> <p>Zero if successful, nonzero if failure</p> Source code in <code>ghedesigner/manager.py</code> <pre><code>def set_double_u_tube_pipe_parallel(\n    self,\n    inner_diameter: float,\n    outer_diameter: float,\n    shank_spacing: float,\n    roughness: float,\n    conductivity: float,\n    rho_cp: float,\n) -&gt; int:\n    \"\"\"\n    Sets the pipe instance for a double u-tube pipe in a parallel configuration.\n\n    :param inner_diameter: inner pipe diameter, in m.\n    :param outer_diameter: outer pipe diameter, in m.\n    :param shank_spacing: shank spacing between the u-tube legs, in m, as measured edge-to-edge.\n    :param roughness: pipe surface roughness, in m.\n    :param conductivity: thermal conductivity, in W/m-K.\n    :param rho_cp: volumetric heat capacity, in J/m^3-K.\n    :returns: Zero if successful, nonzero if failure\n    :rtype: int\n    \"\"\"\n\n    r_in = inner_diameter / 2.0\n    r_out = outer_diameter / 2.0\n\n    self.pipe_type = BHPipeType.DOUBLEUTUBEPARALLEL\n    pipe_positions = Pipe.place_pipes(shank_spacing, r_out, 2)\n    self._pipe = Pipe(pipe_positions, r_in, r_out, shank_spacing, roughness, conductivity, rho_cp)\n    return 0\n</code></pre>"},{"location":"manager/#ghedesigner.manager.GHEManager.set_double_u_tube_pipe_series","title":"<code>set_double_u_tube_pipe_series(inner_diameter, outer_diameter, shank_spacing, roughness, conductivity, rho_cp)</code>","text":"<p>Sets the pipe instance for a double u-tube pipe in a series configuration.</p> <p>Parameters:</p> Name Type Description Default <code>inner_diameter</code> <code>float</code> <p>inner pipe diameter, in m.</p> required <code>outer_diameter</code> <code>float</code> <p>outer pipe diameter, in m.</p> required <code>shank_spacing</code> <code>float</code> <p>shank spacing between the u-tube legs, in m, as measured edge-to-edge.</p> required <code>roughness</code> <code>float</code> <p>pipe surface roughness, in m.</p> required <code>conductivity</code> <code>float</code> <p>thermal conductivity, in W/m-K.</p> required <code>rho_cp</code> <code>float</code> <p>volumetric heat capacity, in J/m^3-K.</p> required <p>Returns:</p> Type Description <code>int</code> <p>Zero if successful, nonzero if failure</p> Source code in <code>ghedesigner/manager.py</code> <pre><code>def set_double_u_tube_pipe_series(\n    self,\n    inner_diameter: float,\n    outer_diameter: float,\n    shank_spacing: float,\n    roughness: float,\n    conductivity: float,\n    rho_cp: float,\n) -&gt; int:\n    \"\"\"\n    Sets the pipe instance for a double u-tube pipe in a series configuration.\n\n    :param inner_diameter: inner pipe diameter, in m.\n    :param outer_diameter: outer pipe diameter, in m.\n    :param shank_spacing: shank spacing between the u-tube legs, in m, as measured edge-to-edge.\n    :param roughness: pipe surface roughness, in m.\n    :param conductivity: thermal conductivity, in W/m-K.\n    :param rho_cp: volumetric heat capacity, in J/m^3-K.\n    :returns: Zero if successful, nonzero if failure\n    :rtype: int\n    \"\"\"\n\n    r_in = inner_diameter / 2.0\n    r_out = outer_diameter / 2.0\n\n    self.pipe_type = BHPipeType.DOUBLEUTUBESERIES\n    pipe_positions = Pipe.place_pipes(shank_spacing, r_out, 2)\n    self._pipe = Pipe(pipe_positions, r_in, r_out, shank_spacing, roughness, conductivity, rho_cp)\n    return 0\n</code></pre>"},{"location":"manager/#ghedesigner.manager.GHEManager.set_fluid","title":"<code>set_fluid(fluid_name='Water', concentration_percent=0.0, temperature=20.0, throw=True)</code>","text":"<p>Sets the fluid instance.</p> <p>Parameters:</p> Name Type Description Default <code>fluid_name</code> <code>str</code> <p>fluid name input string.</p> <code>'Water'</code> <code>concentration_percent</code> <code>float</code> <p>concentration percent of antifreeze mixture.</p> <code>0.0</code> <code>temperature</code> <code>float</code> <p>design fluid temperature, in C.</p> <code>20.0</code> <code>throw</code> <code>bool</code> <p>By default, function will raise an exception on error, override to false to not raise exception</p> <code>True</code> <p>Returns:</p> Type Description <code>int</code> <p>Zero if successful, nonzero if failure</p> Source code in <code>ghedesigner/manager.py</code> <pre><code>def set_fluid(\n    self,\n    fluid_name: str = \"Water\",\n    concentration_percent: float = 0.0,\n    temperature: float = 20.0,\n    throw: bool = True,\n) -&gt; int:\n    \"\"\"\n    Sets the fluid instance.\n\n    :param fluid_name: fluid name input string.\n    :param concentration_percent: concentration percent of antifreeze mixture.\n    :param temperature: design fluid temperature, in C.\n    :param throw: By default, function will raise an exception on error, override to false to not raise exception\n    :returns: Zero if successful, nonzero if failure\n    :rtype: int\n    \"\"\"\n    try:\n        self._fluid = GHEFluid(fluid_str=fluid_name, percent=concentration_percent, temperature=temperature)\n        return 0\n    except ValueError:\n        message = \"Invalid fluid property input data.\"\n        print(message, file=stderr)\n        if throw:\n            raise ValueError(message)\n        return 1\n</code></pre>"},{"location":"manager/#ghedesigner.manager.GHEManager.set_geometry_constraints_bi_rectangle","title":"<code>set_geometry_constraints_bi_rectangle(length, width, b_min, b_max_x, b_max_y)</code>","text":"<p>Sets the geometry constraints for the bi-rectangle design method.</p> <p>Parameters:</p> Name Type Description Default <code>length</code> <code>float</code> <p>side length of the sizing domain, in m.</p> required <code>width</code> <code>float</code> <p>side width of the sizing domain, in m.</p> required <code>b_min</code> <code>float</code> <p>minimum borehole-to-borehole spacing, in m.</p> required <code>b_max_x</code> <code>float</code> <p>maximum borehole-to-borehole spacing in the x-direction, in m.</p> required <code>b_max_y</code> <code>float</code> <p>maximum borehole-to-borehole spacing in the y-direction, in m.</p> required <p>Returns:</p> Type Description <code>int</code> <p>Zero if successful, nonzero if failure</p> Source code in <code>ghedesigner/manager.py</code> <pre><code>def set_geometry_constraints_bi_rectangle(\n    self, length: float, width: float, b_min: float, b_max_x: float, b_max_y: float\n) -&gt; int:\n    \"\"\"\n    Sets the geometry constraints for the bi-rectangle design method.\n\n    :param length: side length of the sizing domain, in m.\n    :param width: side width of the sizing domain, in m.\n    :param b_min: minimum borehole-to-borehole spacing, in m.\n    :param b_max_x: maximum borehole-to-borehole spacing in the x-direction, in m.\n    :param b_max_y: maximum borehole-to-borehole spacing in the y-direction, in m.\n    :returns: Zero if successful, nonzero if failure\n    :rtype: int\n    \"\"\"\n    self.geom_type = DesignGeomType.BIRECTANGLE\n    self._geometric_constraints = GeometricConstraintsBiRectangle(width, length, b_min, b_max_x, b_max_y)\n    return 0\n</code></pre>"},{"location":"manager/#ghedesigner.manager.GHEManager.set_geometry_constraints_bi_rectangle_constrained","title":"<code>set_geometry_constraints_bi_rectangle_constrained(b_min, b_max_x, b_max_y, property_boundary, no_go_boundaries)</code>","text":"<p>Sets the geometry constraints for the bi-rectangle constrained design method.</p> <p>Parameters:</p> Name Type Description Default <code>b_min</code> <code>float</code> <p>minimum borehole-to-borehole spacing, in m.</p> required <code>b_max_x</code> <code>float</code> <p>maximum borehole-to-borehole spacing in the x-direction, in m.</p> required <code>b_max_y</code> <code>float</code> <p>maximum borehole-to-borehole spacing in the y-direction, in m.</p> required <code>property_boundary</code> <code>list</code> <p>property boundary points, in m.</p> required <code>no_go_boundaries</code> <code>list</code> <p>boundary points for no-go zones, in m.</p> required <p>Returns:</p> Type Description <code>int</code> <p>Zero if successful, nonzero if failure</p> Source code in <code>ghedesigner/manager.py</code> <pre><code>def set_geometry_constraints_bi_rectangle_constrained(\n    self, b_min: float, b_max_x: float, b_max_y: float, property_boundary: list, no_go_boundaries: list\n) -&gt; int:\n    \"\"\"\n    Sets the geometry constraints for the bi-rectangle constrained design method.\n\n    :param b_min: minimum borehole-to-borehole spacing, in m.\n    :param b_max_x: maximum borehole-to-borehole spacing in the x-direction, in m.\n    :param b_max_y: maximum borehole-to-borehole spacing in the y-direction, in m.\n    :param property_boundary: property boundary points, in m.\n    :param no_go_boundaries: boundary points for no-go zones, in m.\n    :returns: Zero if successful, nonzero if failure\n    :rtype: int\n    \"\"\"\n    self.geom_type = DesignGeomType.BIRECTANGLECONSTRAINED\n    self._geometric_constraints = GeometricConstraintsBiRectangleConstrained(\n        b_min, b_max_x, b_max_y, property_boundary, no_go_boundaries\n    )\n    return 0\n</code></pre>"},{"location":"manager/#ghedesigner.manager.GHEManager.set_geometry_constraints_bi_zoned_rectangle","title":"<code>set_geometry_constraints_bi_zoned_rectangle(length, width, b_min, b_max_x, b_max_y)</code>","text":"<p>Sets the geometry constraints for the bi-zoned rectangle design method.</p> <p>Parameters:</p> Name Type Description Default <code>length</code> <code>float</code> <p>side length of the sizing domain, in m.</p> required <code>width</code> <code>float</code> <p>side width of the sizing domain, in m.</p> required <code>b_min</code> <code>float</code> <p>minimum borehole-to-borehole spacing, in m.</p> required <code>b_max_x</code> <code>float</code> <p>maximum borehole-to-borehole spacing in the x-direction, in m.</p> required <code>b_max_y</code> <code>float</code> <p>maximum borehole-to-borehole spacing in the y-direction, in m.</p> required <p>Returns:</p> Type Description <code>int</code> <p>Zero if successful, nonzero if failure</p> Source code in <code>ghedesigner/manager.py</code> <pre><code>def set_geometry_constraints_bi_zoned_rectangle(\n    self, length: float, width: float, b_min: float, b_max_x: float, b_max_y: float\n) -&gt; int:\n    \"\"\"\n    Sets the geometry constraints for the bi-zoned rectangle design method.\n\n    :param length: side length of the sizing domain, in m.\n    :param width: side width of the sizing domain, in m.\n    :param b_min: minimum borehole-to-borehole spacing, in m.\n    :param b_max_x: maximum borehole-to-borehole spacing in the x-direction, in m.\n    :param b_max_y: maximum borehole-to-borehole spacing in the y-direction, in m.\n    :returns: Zero if successful, nonzero if failure\n    :rtype: int\n    \"\"\"\n    self.geom_type = DesignGeomType.BIZONEDRECTANGLE\n    self._geometric_constraints = GeometricConstraintsBiZoned(width, length, b_min, b_max_x, b_max_y)\n    return 0\n</code></pre>"},{"location":"manager/#ghedesigner.manager.GHEManager.set_geometry_constraints_near_square","title":"<code>set_geometry_constraints_near_square(b, length)</code>","text":"<p>Sets the geometry constraints for the near-square design method.</p> <p>Parameters:</p> Name Type Description Default <code>b</code> <code>float</code> <p>borehole-to-borehole spacing, in m.</p> required <code>length</code> <code>float</code> <p>side length of the sizing domain, in m.</p> required <p>Returns:</p> Type Description <code>int</code> <p>Zero if successful, nonzero if failure</p> Source code in <code>ghedesigner/manager.py</code> <pre><code>def set_geometry_constraints_near_square(self, b: float, length: float) -&gt; int:\n    \"\"\"\n    Sets the geometry constraints for the near-square design method.\n\n    :param b: borehole-to-borehole spacing, in m.\n    :param length: side length of the sizing domain, in m.\n    :returns: Zero if successful, nonzero if failure\n    :rtype: int\n    \"\"\"\n    self._geometric_constraints = GeometricConstraintsNearSquare(b, length)\n    return 0\n</code></pre>"},{"location":"manager/#ghedesigner.manager.GHEManager.set_geometry_constraints_rectangle","title":"<code>set_geometry_constraints_rectangle(length, width, b_min, b_max)</code>","text":"<p>Sets the geometry constraints for the rectangle design method.</p> <p>Parameters:</p> Name Type Description Default <code>length</code> <code>float</code> <p>side length of the sizing domain, in m.</p> required <code>width</code> <code>float</code> <p>side width of the sizing domain, in m.</p> required <code>b_min</code> <code>float</code> <p>minimum borehole-to-borehole spacing, in m.</p> required <code>b_max</code> <code>float</code> <p>maximum borehole-to-borehole spacing, in m.</p> required <p>Returns:</p> Type Description <code>int</code> <p>Zero if successful, nonzero if failure</p> Source code in <code>ghedesigner/manager.py</code> <pre><code>def set_geometry_constraints_rectangle(self, length: float, width: float, b_min: float, b_max: float) -&gt; int:\n    \"\"\"\n    Sets the geometry constraints for the rectangle design method.\n\n    :param length: side length of the sizing domain, in m.\n    :param width: side width of the sizing domain, in m.\n    :param b_min: minimum borehole-to-borehole spacing, in m.\n    :param b_max: maximum borehole-to-borehole spacing, in m.\n    :returns: Zero if successful, nonzero if failure\n    :rtype: int\n    \"\"\"\n    self.geom_type = DesignGeomType.RECTANGLE\n    self._geometric_constraints = GeometricConstraintsRectangle(width, length, b_min, b_max)\n    return 0\n</code></pre>"},{"location":"manager/#ghedesigner.manager.GHEManager.set_geometry_constraints_rowwise","title":"<code>set_geometry_constraints_rowwise(perimeter_spacing_ratio, max_spacing, min_spacing, spacing_step, max_rotation, min_rotation, rotate_step, property_boundary, no_go_boundaries)</code>","text":"<p>Sets the geometry constraints for the row-wise design method.</p> <p>Parameters:</p> Name Type Description Default <code>perimeter_spacing_ratio</code> <code>float | None</code> <p>the ratio between the minimum spacing between boreholes placed along the property and no-go zones and the standard borehole-to-borehole spacing used for internal boreholes.</p> required <code>max_spacing</code> <code>float</code> <p>the largest minimum spacing that will be used to generate a RowWise field.</p> required <code>min_spacing</code> <code>float</code> <p>the smallest minimum spacing that will be used to generate a RowWise field.</p> required <code>spacing_step</code> <code>float</code> <p>the distance in spacing from the design found in the first part of first search to exhaustively check in the second part.</p> required <code>max_rotation</code> <code>float</code> <p>the maximum rotation of the rows of each field relative to horizontal that will be used in the search.</p> required <code>min_rotation</code> <code>float</code> <p>the minimum rotation of the rows of each field relative to horizontal that will be used in the search.</p> required <code>rotate_step</code> <code>float</code> <p>step size for field rotation search.</p> required <code>property_boundary</code> <code>list</code> <p>property boundary points.</p> required <code>no_go_boundaries</code> <code>list</code> <p>boundary points for no-go zones.</p> required <p>Returns:</p> Type Description <code>int</code> <p>Zero if successful, nonzero if failure</p> Source code in <code>ghedesigner/manager.py</code> <pre><code>def set_geometry_constraints_rowwise(\n    self,\n    perimeter_spacing_ratio: float | None,\n    max_spacing: float,\n    min_spacing: float,\n    spacing_step: float,\n    max_rotation: float,\n    min_rotation: float,\n    rotate_step: float,\n    property_boundary: list,\n    no_go_boundaries: list,\n) -&gt; int:\n    \"\"\"\n    Sets the geometry constraints for the row-wise design method.\n\n    :param perimeter_spacing_ratio: the ratio between the minimum spacing between\n        boreholes placed along the property and no-go zones and the standard borehole-to-borehole\n        spacing used for internal boreholes.\n    :param max_spacing: the largest minimum spacing that will be used to generate a RowWise field.\n    :param min_spacing: the smallest minimum spacing that will be used to generate a RowWise field.\n    :param spacing_step: the distance in spacing from the design found in the first part of first\n        search to exhaustively check in the second part.\n    :param max_rotation: the maximum rotation of the rows of each field relative to horizontal that\n        will be used in the search.\n    :param min_rotation: the minimum rotation of the rows of each field relative to horizontal that\n        will be used in the search.\n    :param rotate_step: step size for field rotation search.\n    :param property_boundary: property boundary points.\n    :param no_go_boundaries: boundary points for no-go zones.\n    :returns: Zero if successful, nonzero if failure\n    :rtype: int\n    \"\"\"\n\n    # convert from degrees to radians\n    max_rotation = max_rotation * DEG_TO_RAD\n    min_rotation = min_rotation * DEG_TO_RAD\n\n    self.geom_type = DesignGeomType.ROWWISE\n    self._geometric_constraints = GeometricConstraintsRowWise(\n        perimeter_spacing_ratio,\n        min_spacing,\n        max_spacing,\n        spacing_step,\n        min_rotation,\n        max_rotation,\n        rotate_step,\n        property_boundary,\n        no_go_boundaries,\n    )\n    return 0\n</code></pre>"},{"location":"manager/#ghedesigner.manager.GHEManager.set_ground_loads_from_hourly_list","title":"<code>set_ground_loads_from_hourly_list(hourly_ground_loads)</code>","text":"<p>Sets the ground loads based on a list input.</p> <p>Parameters:</p> Name Type Description Default <code>hourly_ground_loads</code> <code>list[float]</code> <p>annual, hourly ground loads, in W. positive values indicate heat extraction, negative values indicate heat rejection.</p> required <p>Returns:</p> Type Description <code>int</code> <p>Zero if successful, nonzero if failure</p> Source code in <code>ghedesigner/manager.py</code> <pre><code>def set_ground_loads_from_hourly_list(self, hourly_ground_loads: list[float]) -&gt; int:\n    \"\"\"\n    Sets the ground loads based on a list input.\n\n    :param hourly_ground_loads: annual, hourly ground loads, in W.\n     positive values indicate heat extraction, negative values indicate heat rejection.\n    :returns: Zero if successful, nonzero if failure\n    :rtype: int\n    \"\"\"\n    # TODO: Add API methods for different load inputs\n    self._ground_loads = hourly_ground_loads\n    return 0\n</code></pre>"},{"location":"manager/#ghedesigner.manager.GHEManager.set_grout","title":"<code>set_grout(conductivity, rho_cp)</code>","text":"<p>Sets the grout instance.</p> <p>Parameters:</p> Name Type Description Default <code>conductivity</code> <code>float</code> <p>thermal conductivity, in W/m-K.</p> required <code>rho_cp</code> <code>float</code> <p>volumetric heat capacity, in J/m^3-K.</p> required <p>Returns:</p> Type Description <code>int</code> <p>Zero if successful, nonzero if failure</p> Source code in <code>ghedesigner/manager.py</code> <pre><code>def set_grout(self, conductivity: float, rho_cp: float) -&gt; int:\n    \"\"\"\n    Sets the grout instance.\n\n    :param conductivity: thermal conductivity, in W/m-K.\n    :param rho_cp: volumetric heat capacity, in J/m^3-K.\n    :returns: Zero if successful, nonzero if failure\n    :rtype: int\n    \"\"\"\n    self._grout = Grout(conductivity, rho_cp)\n    return 0\n</code></pre>"},{"location":"manager/#ghedesigner.manager.GHEManager.set_pipe_type","title":"<code>set_pipe_type(bh_pipe_str, throw=True)</code>","text":"<p>Sets the borehole pipe type.</p> <p>Parameters:</p> Name Type Description Default <code>bh_pipe_str</code> <code>str</code> <p>pipe type input string.</p> required <code>throw</code> <code>bool</code> <p>By default, function will raise an exception on error, override to false to not raise exception</p> <code>True</code> <p>Returns:</p> Type Description <code>int</code> <p>Zero if successful, nonzero if failure</p> Source code in <code>ghedesigner/manager.py</code> <pre><code>def set_pipe_type(self, bh_pipe_str: str, throw: bool = True) -&gt; int:\n    \"\"\"\n    Sets the borehole pipe type.\n\n    :param bh_pipe_str: pipe type input string.\n    :param throw: By default, function will raise an exception on error, override to false to not raise exception\n    :returns: Zero if successful, nonzero if failure\n    :rtype: int\n    \"\"\"\n    bh_pipe_str = str(bh_pipe_str).upper()\n    if bh_pipe_str == BHPipeType.SINGLEUTUBE.name:\n        self.pipe_type = BHPipeType.SINGLEUTUBE\n    elif bh_pipe_str == BHPipeType.DOUBLEUTUBEPARALLEL.name:\n        self.pipe_type = BHPipeType.DOUBLEUTUBEPARALLEL\n    elif bh_pipe_str == BHPipeType.DOUBLEUTUBESERIES.name:\n        self.pipe_type = BHPipeType.DOUBLEUTUBESERIES\n    elif bh_pipe_str == BHPipeType.COAXIAL.name:\n        self.pipe_type = BHPipeType.COAXIAL\n    else:\n        message = f\"Borehole pipe type \\\"{bh_pipe_str}\\\" not supported.\"\n        print(message, file=stderr)\n        if throw:\n            raise ValueError(message)\n        return 1\n\n    return 0\n</code></pre>"},{"location":"manager/#ghedesigner.manager.GHEManager.set_simulation_parameters","title":"<code>set_simulation_parameters(num_months, max_eft, min_eft, max_height, min_height, max_boreholes=None, continue_if_design_unmet=False)</code>","text":"<p>Sets the simulation parameters</p> <p>Parameters:</p> Name Type Description Default <code>num_months</code> <code>int</code> <p>number of months in simulation.</p> required <code>max_eft</code> <code>float</code> <p>maximum heat pump entering fluid temperature, in C.</p> required <code>min_eft</code> <code>float</code> <p>minimum heat pump entering fluid temperature, in C.</p> required <code>max_height</code> <code>float</code> <p>maximum height of borehole, in m.</p> required <code>min_height</code> <code>float</code> <p>minimum height of borehole, in m.</p> required <code>max_boreholes</code> <code>int | None</code> <p>maximum boreholes in search algorithms.</p> <code>None</code> <code>continue_if_design_unmet</code> <code>bool</code> <p>continues to process if design unmet.</p> <code>False</code> <p>Returns:</p> Type Description <code>int</code> <p>Zero if successful, nonzero if failure</p> Source code in <code>ghedesigner/manager.py</code> <pre><code>def set_simulation_parameters(\n    self,\n    num_months: int,\n    max_eft: float,\n    min_eft: float,\n    max_height: float,\n    min_height: float,\n    max_boreholes: int | None = None,\n    continue_if_design_unmet: bool = False,\n) -&gt; int:\n    \"\"\"\n    Sets the simulation parameters\n\n    :param num_months: number of months in simulation.\n    :param max_eft: maximum heat pump entering fluid temperature, in C.\n    :param min_eft: minimum heat pump entering fluid temperature, in C.\n    :param max_height: maximum height of borehole, in m.\n    :param min_height: minimum height of borehole, in m.\n    :param max_boreholes: maximum boreholes in search algorithms.\n    :param continue_if_design_unmet: continues to process if design unmet.\n    :returns: Zero if successful, nonzero if failure\n    :rtype: int\n    \"\"\"\n    self._simulation_parameters = SimulationParameters(\n        1, num_months, max_eft, min_eft, max_height, min_height, max_boreholes, continue_if_design_unmet\n    )\n    return 0\n</code></pre>"},{"location":"manager/#ghedesigner.manager.GHEManager.set_single_u_tube_pipe","title":"<code>set_single_u_tube_pipe(inner_diameter, outer_diameter, shank_spacing, roughness, conductivity, rho_cp)</code>","text":"<p>Sets the pipe instance for a single u-tube pipe.</p> <p>Parameters:</p> Name Type Description Default <code>inner_diameter</code> <code>float</code> <p>inner pipe diameter, in m.</p> required <code>outer_diameter</code> <code>float</code> <p>outer pipe diameter, in m.</p> required <code>shank_spacing</code> <code>float</code> <p>shank spacing between the u-tube legs, in m, as measured edge-to-edge.</p> required <code>roughness</code> <code>float</code> <p>pipe surface roughness, in m.</p> required <code>conductivity</code> <code>float</code> <p>thermal conductivity, in W/m-K.</p> required <code>rho_cp</code> <code>float</code> <p>volumetric heat capacity, in J/m^3-K.</p> required <p>Returns:</p> Type Description <code>int</code> <p>Zero if successful, nonzero if failure</p> Source code in <code>ghedesigner/manager.py</code> <pre><code>def set_single_u_tube_pipe(\n    self,\n    inner_diameter: float,\n    outer_diameter: float,\n    shank_spacing: float,\n    roughness: float,\n    conductivity: float,\n    rho_cp: float,\n) -&gt; int:\n    \"\"\"\n    Sets the pipe instance for a single u-tube pipe.\n\n    :param inner_diameter: inner pipe diameter, in m.\n    :param outer_diameter: outer pipe diameter, in m.\n    :param shank_spacing: shank spacing between the u-tube legs, in m, as measured edge-to-edge.\n    :param roughness: pipe surface roughness, in m.\n    :param conductivity: thermal conductivity, in W/m-K.\n    :param rho_cp: volumetric heat capacity, in J/m^3-K.\n    :returns: Zero if successful, nonzero if failure\n    :rtype: int\n    \"\"\"\n\n    r_in = inner_diameter / 2.0\n    r_out = outer_diameter / 2.0\n\n    self.pipe_type = BHPipeType.SINGLEUTUBE\n    pipe_positions = Pipe.place_pipes(shank_spacing, r_out, 1)\n    self._pipe = Pipe(pipe_positions, r_in, r_out, shank_spacing, roughness, conductivity, rho_cp)\n    return 0\n</code></pre>"},{"location":"manager/#ghedesigner.manager.GHEManager.set_soil","title":"<code>set_soil(conductivity, rho_cp, undisturbed_temp)</code>","text":"<p>Sets the soil instance.</p> <p>Parameters:</p> Name Type Description Default <code>conductivity</code> <code>float</code> <p>thermal conductivity, in W/m-K.</p> required <code>rho_cp</code> <code>float</code> <p>volumetric heat capacity, in J/m^3-K.</p> required <code>undisturbed_temp</code> <code>float</code> <p>undisturbed soil temperature, in C.</p> required <p>Returns:</p> Type Description <code>int</code> <p>Zero if successful, nonzero if failure</p> Source code in <code>ghedesigner/manager.py</code> <pre><code>def set_soil(self, conductivity: float, rho_cp: float, undisturbed_temp: float) -&gt; int:\n    \"\"\"\n    Sets the soil instance.\n\n    :param conductivity: thermal conductivity, in W/m-K.\n    :param rho_cp: volumetric heat capacity, in J/m^3-K.\n    :param undisturbed_temp: undisturbed soil temperature, in C.\n    :returns: Zero if successful, nonzero if failure\n    :rtype: int\n    \"\"\"\n    self._soil = Soil(conductivity, rho_cp, undisturbed_temp)\n    return 0\n</code></pre>"},{"location":"manager/#ghedesigner.manager.GHEManager.write_input_file","title":"<code>write_input_file(output_file_path, throw=True)</code>","text":"<p>Writes an input file based on current simulation configuration.</p> <p>Parameters:</p> Name Type Description Default <code>output_file_path</code> <code>Path</code> <p>output directory to write input file.</p> required <code>throw</code> <code>bool</code> <p>By default, function will raise an exception on error, override to false to not raise exception</p> <code>True</code> <p>Returns:</p> Type Description <code>int</code> <p>Zero if successful, nonzero if failure</p> Source code in <code>ghedesigner/manager.py</code> <pre><code>def write_input_file(self, output_file_path: Path, throw: bool = True) -&gt; int:\n    \"\"\"\n    Writes an input file based on current simulation configuration.\n\n    :param output_file_path: output directory to write input file.\n    :param throw: By default, function will raise an exception on error, override to false to not raise exception\n    :returns: Zero if successful, nonzero if failure\n    :rtype: int\n    \"\"\"\n\n    # TODO: geometric constraints are currently held in two places\n    #       SimulationParameters and GeometricConstraints\n    #       these should be consolidated\n    d_geo = self._geometric_constraints.to_input()\n    d_geo['max_height'] = self._simulation_parameters.max_height\n    d_geo['min_height'] = self._simulation_parameters.min_height\n\n    # TODO: data held in different places\n    d_des = self._design.to_input()\n    d_des['max_eft'] = self._simulation_parameters.max_EFT_allowable\n    d_des['min_eft'] = self._simulation_parameters.min_EFT_allowable\n\n    if self._simulation_parameters.max_boreholes is not None:\n        d_des['max_boreholes'] = self._simulation_parameters.max_boreholes\n    if self._simulation_parameters.continue_if_design_unmet is True:\n        d_des['continue_if_design_unmet'] = self._simulation_parameters.continue_if_design_unmet\n\n    # pipe data\n    d_pipe = {'rho_cp': self._pipe.rhoCp, 'roughness': self._pipe.roughness}\n\n    if self.pipe_type in [BHPipeType.SINGLEUTUBE, BHPipeType.DOUBLEUTUBEPARALLEL, BHPipeType.DOUBLEUTUBESERIES]:\n        d_pipe['inner_diameter'] = self._pipe.r_in * 2.0\n        d_pipe['outer_diameter'] = self._pipe.r_out * 2.0\n        d_pipe['shank_spacing'] = self._pipe.s\n        d_pipe['conductivity'] = self._pipe.k\n    elif self.pipe_type == BHPipeType.COAXIAL:\n        d_pipe['inner_pipe_d_in'] = self._pipe.r_in[0] * 2.0\n        d_pipe['inner_pipe_d_out'] = self._pipe.r_in[1] * 2.0\n        d_pipe['outer_pipe_d_in'] = self._pipe.r_out[0] * 2.0\n        d_pipe['outer_pipe_d_out'] = self._pipe.r_out[1] * 2.0\n        d_pipe['conductivity_inner'] = self._pipe.k[0]\n        d_pipe['conductivity_outer'] = self._pipe.k[1]\n    else:\n        message = 'Invalid pipe type'\n        print(message, file=stderr)\n        if throw:\n            raise ValueError(message)\n        return 1\n\n    if self.pipe_type == BHPipeType.SINGLEUTUBE:\n        d_pipe['arrangement'] = BHPipeType.SINGLEUTUBE.name\n    elif self.pipe_type == BHPipeType.DOUBLEUTUBEPARALLEL:\n        d_pipe['arrangement'] = BHPipeType.DOUBLEUTUBEPARALLEL.name\n    elif self.pipe_type == BHPipeType.DOUBLEUTUBESERIES:\n        d_pipe['arrangement'] = BHPipeType.DOUBLEUTUBESERIES.name\n    elif self.pipe_type == BHPipeType.COAXIAL:\n        d_pipe['arrangement'] = BHPipeType.COAXIAL.name\n    else:\n        message = 'Invalid pipe type'\n        print(message, file=stderr)\n        if throw:\n            raise ValueError(message)\n        return 1\n\n    d = {\n        'version': VERSION,\n        'fluid': self._fluid.to_input(),\n        'grout': self._grout.to_input(),\n        'soil': self._soil.to_input(),\n        'pipe': d_pipe,\n        'borehole': self._borehole.to_input(),\n        'simulation': self._simulation_parameters.to_input(),\n        'geometric_constraints': d_geo,\n        'design': d_des,\n        'loads': {'ground_loads': list(self._ground_loads)},\n    }\n\n    with open(output_file_path, 'w') as f:\n        f.write(dumps(d, sort_keys=True, indent=2, separators=(',', ': ')))\n    return 0\n</code></pre>"},{"location":"manager/#ghedesigner.manager.GHEManager.write_output_files","title":"<code>write_output_files(output_directory, output_file_suffix='')</code>","text":"<p>Writes the output files.</p> <p>Parameters:</p> Name Type Description Default <code>output_directory</code> <code>Path</code> <p>output directory for output files.</p> required <code>output_file_suffix</code> <code>str</code> <p>adds a string suffix to the output files.</p> <code>''</code> Source code in <code>ghedesigner/manager.py</code> <pre><code>def write_output_files(self, output_directory: Path, output_file_suffix: str = \"\"):\n    \"\"\"\n    Writes the output files.\n\n    :param output_directory: output directory for output files.\n    :param output_file_suffix: adds a string suffix to the output files.\n    \"\"\"\n    self.results.write_all_output_files(output_directory=output_directory, file_suffix=output_file_suffix)\n</code></pre>"},{"location":"schema/geometric_bi_rectangle.schema/","title":"JSON Schema","text":""},{"location":"schema/geometric_bi_rectangle.schema/#properties","title":"Properties","text":"<ul> <li><code>length</code> (number, format: Meters, required): Horizontal length of property boundary defining surface area available for ground heat exchanger. Minimum: <code>0</code>.</li> <li><code>width</code> (number, format: Meters, required): Horizontal width of property boundary defining surface area available for ground heat exchanger. Minimum: <code>0</code>.</li> <li><code>b_min</code> (number, format: Meters, required): Minimum borehole-to-borehole spacing. Minimum: <code>0</code>.</li> <li><code>b_max_x</code> (number, format: Meters, required): Maximum borehole-to-borehole spacing in x-direction. Minimum: <code>0</code>.</li> <li><code>b_max_y</code> (number, format: Meters, required): Maximum borehole-to-borehole spacing in y-direction. Minimum: <code>0</code>.</li> <li><code>max_height</code> (number, format: Meters, required): Maximum height, or active length, of each borehole heat exchanger. Minimum: <code>0</code>.</li> <li><code>min_height</code> (number, format: Meters, required): Minimum height, or active length, of each borehole heat exchanger. Minimum: <code>0</code>.</li> <li><code>method</code> (string, required): Design algorithm specified. Must be: <code>\"BIRECTANGLE\"</code>.</li> </ul>"},{"location":"schema/fluid.schema/","title":"JSON Schema","text":""},{"location":"schema/fluid.schema/#properties","title":"Properties","text":"<ul> <li><code>fluid_name</code> (string, required): Circulation fluid type. Must be one of: <code>[\"WATER\", \"ETHYLALCOHOL\", \"ETHYLENEGLYCOL\", \"METHYLALCOHOL\", \"PROPYLENEGLYCOL\"]</code>.</li> <li><code>concentration_percent</code> (number, format: Percent, required): Mass fraction concentration percent of circulation fluid. e.g.: '0' indicates pure water; '20' indicates 20% antifreeze, 80% pure water. Minimum: <code>0</code>. Maximum: <code>60</code>.</li> <li><code>temperature</code> (number, format: Centigrade, required): Average design fluid temperature at peak conditions.</li> </ul>"},{"location":"schema/loads.schema/","title":"JSON Schema","text":""},{"location":"schema/loads.schema/#properties","title":"Properties","text":"<ul> <li><code>ground_loads</code> (array, format: Watts, required): Annual, hourly heat extraction and heat rejection loads of the ground heat exchanger. Positive value indicate heat extraction, negative values indicate heat rejection. Length must be equal to 8760.</li> <li>Items (number)</li> <li><code>heat_pump_loads</code> (array, format: Watts): This field is currently unused. Length must be equal to 8760.</li> <li>Items (number)</li> </ul>"},{"location":"schema/file_structure.schema/","title":"JSON Schema","text":""},{"location":"schema/file_structure.schema/#properties","title":"Properties","text":"<ul> <li><code>version</code> (string, required): Version of input file.</li> <li><code>fluid</code> (object, required): Object used to define parameters related to the circulation fluid.</li> <li><code>grout</code> (object, required): Object used to define parameters related to grout material.</li> <li><code>soil</code> (object, required): Object used to define parameters related to soil material.</li> <li><code>pipe</code> (object, required): Object used to define parameters related the pipes.</li> <li><code>borehole</code> (object, required): Object used to define parameters related the borehole.</li> <li><code>simulation</code> (object, required): Object used to define parameters related to simulation.</li> <li><code>geometric_constraints</code> (object, required): Object used to define geometric constraint parameters for the selected design algorithm.</li> <li><code>design</code> (object, required): Object used to define parameters related to design and sizing.</li> <li><code>loads</code> (object, required): Object used to define loads for design and sizing.</li> </ul>"},{"location":"schema/grout.schema/","title":"JSON Schema","text":""},{"location":"schema/grout.schema/#properties","title":"Properties","text":"<ul> <li><code>conductivity</code> (number, format: Watts/Meter-Kelvin, required): Thermal conductivity. Minimum: <code>0</code>.</li> <li><code>rho_cp</code> (number, format: Joules/Meter^3-Kelvin, required): Volumetric heat capacity. Minimum: <code>0</code>.</li> </ul>"},{"location":"schema/pipe_coaxial.schema/","title":"JSON Schema","text":""},{"location":"schema/pipe_coaxial.schema/#properties","title":"Properties","text":"<ul> <li><code>inner_pipe_d_in</code> (number, format: Meters, required): Inner pipe inner diameter. Minimum: <code>0</code>.</li> <li><code>inner_pipe_d_out</code> (number, format: Meters, required): Inner pipe outer diameter. Minimum: <code>0</code>.</li> <li><code>outer_pipe_d_in</code> (number, format: Meters, required): Outer pipe inner diameter. Minimum: <code>0</code>.</li> <li><code>outer_pipe_d_out</code> (number, format: Meters, required): Outer pipe outer diameter. Minimum: <code>0</code>.</li> <li><code>roughness</code> (number, format: Meters, required): Surface roughness. Minimum: <code>0</code>.</li> <li><code>conductivity_inner</code> (number, format: W/Meters-K, required): Thermal conductivity of inner pipe. Minimum: <code>0</code>.</li> <li><code>conductivity_outer</code> (number, format: Watts/Meter-Kelvin, required): Thermal conductivity of outer pipe. Minimum: <code>0</code>.</li> <li><code>rho_cp</code> (number, format: Joules/Meter^3-Kelvin, required): Volumetric heat capacity. Minimum: <code>0</code>.</li> <li><code>arrangement</code> (string, required): Pipe arrangement specified. Must be: <code>\"COAXIAL\"</code>.</li> </ul>"},{"location":"schema/pipe_single_double_u_tube.schema/","title":"JSON Schema","text":""},{"location":"schema/pipe_single_double_u_tube.schema/#properties","title":"Properties","text":"<ul> <li><code>inner_diameter</code> (number, format: Meters, required): Inner diameter of pipe. Minimum: <code>0</code>.</li> <li><code>outer_diameter</code> (number, format: Meters, required): Outer diameter of pipe. Minimum: <code>0</code>.</li> <li><code>shank_spacing</code> (number, format: Meters, required): Spacing between up/down legs of u-tube pipe, as measured from nearest outer surfaces of each pipe (o&lt;-- s --&gt;o). Minimum: <code>0</code>.</li> <li><code>roughness</code> (number, format: Meters, required): Surface roughness of pipe. Minimum: <code>0</code>.</li> <li><code>conductivity</code> (number, format: Watts/Meter-Kelvin, required): Thermal conductivity. Minimum: <code>0</code>.</li> <li><code>rho_cp</code> (number, format: Joules/Meter^3-Kelvin, required): Volumetric heat capacity. Minimum: <code>0</code>.</li> <li><code>arrangement</code> (string, required): Pipe arrangement specified. Must be one of: <code>[\"SINGLEUTUBE\", \"DOUBLEUTUBESERIES\", \"DOUBLEUTUBEPARALLEL\"]</code>.</li> </ul>"},{"location":"schema/geometric_near_square.schema/","title":"JSON Schema","text":""},{"location":"schema/geometric_near_square.schema/#properties","title":"Properties","text":"<ul> <li><code>length</code> (number, format: Meters, required): Horizontal side-length of property boundary defining surface area available for ground heat exchanger. Minimum: <code>0</code>.</li> <li><code>b</code> (number, format: Meters, required): Borehole-to-borehole spacing. Minimum: <code>0</code>.</li> <li><code>max_height</code> (number, format: Meters, required): Maximum height, or active length, of each borehole heat exchanger. Minimum: <code>0</code>.</li> <li><code>min_height</code> (number, format: Meters, required): Minimum height, or active length, of each borehole heat exchanger. Minimum: <code>0</code>.</li> <li><code>method</code> (string, required): Design algorithm specified. Must be: <code>\"NEARSQUARE\"</code>.</li> </ul>"},{"location":"schema/geometric_rectangle.schema/","title":"JSON Schema","text":""},{"location":"schema/geometric_rectangle.schema/#properties","title":"Properties","text":"<ul> <li><code>length</code> (number, format: Meters, required): Horizontal length of property boundary defining surface area available for ground heat exchanger. Minimum: <code>0</code>.</li> <li><code>width</code> (number, format: Meters, required): Horizontal width of property boundary defining surface area available for ground heat exchanger. Minimum: <code>0</code>.</li> <li><code>b_min</code> (number, format: Meters, required): Minimum borehole-to-borehole spacing. Minimum: <code>0</code>.</li> <li><code>b_max</code> (number, format: Meters, required): Maximum borehole-to-borehole spacing. Minimum: <code>0</code>.</li> <li><code>max_height</code> (number, format: Meters, required): Maximum height, or active length, of each borehole heat exchanger. Minimum: <code>0</code>.</li> <li><code>min_height</code> (number, format: Meters, required): Minimum height, or active length, of each borehole heat exchanger. Minimum: <code>0</code>.</li> <li><code>method</code> (string, required): Design algorithm specified. Must be: <code>\"RECTANGLE\"</code>.</li> </ul>"},{"location":"schema/geometric_bi_zoned_rectangle.schema/","title":"JSON Schema","text":""},{"location":"schema/geometric_bi_zoned_rectangle.schema/#properties","title":"Properties","text":"<ul> <li><code>length</code> (number, format: Meters, required): Horizontal length of property boundary defining surface area available for ground heat exchanger. Minimum: <code>0</code>.</li> <li><code>width</code> (number, format: Meters, required): Horizontal width of property boundary defining surface area available for ground heat exchanger. Minimum: <code>0</code>.</li> <li><code>b_min</code> (number, format: Meters, required): Minimum borehole-to-borehole spacing. Minimum: <code>0</code>.</li> <li><code>b_max_x</code> (number, format: Meters, required): Maximum borehole-to-borehole spacing in x-direction. Minimum: <code>0</code>.</li> <li><code>b_max_y</code> (number, format: Meters, required): Maximum borehole-to-borehole spacing in y-direction. Minimum: <code>0</code>.</li> <li><code>max_height</code> (number, format: Meters, required): Maximum height, or active length, of each borehole heat exchanger. Minimum: <code>0</code>.</li> <li><code>min_height</code> (number, format: Meters, required): Minimum height, or active length, of each borehole heat exchanger. Minimum: <code>0</code>.</li> <li><code>method</code> (string, required): Design algorithm specified. Must be: <code>\"BIZONEDRECTANGLE\"</code>.</li> </ul>"},{"location":"schema/simulation.schema/","title":"JSON Schema","text":""},{"location":"schema/simulation.schema/#properties","title":"Properties","text":"<ul> <li><code>start_month</code> (string): This field is currently unused. Must be one of: <code>[\"JANUARY\", \"FEBRUARY\", \"MARCH\", \"APRIL\", \"MAY\", \"JUNE\", \"JULY\", \"AUGUST\", \"SEPTEMBER\", \"OCTOBER\", \"NOVEMBER\", \"DECEMBER\"]</code>. Default: <code>\"JANUARY\"</code>.</li> <li><code>num_months</code> (number, format: Months, required): Number of months used in ground heat exchanger sizing. Minimum: <code>1</code>.</li> <li><code>timestep</code> (string): This field is currently unused. Simulation timestep used in ground heat exchanger sizing. 'HYBRID' is the only option currently available. Must be one of: <code>[\"HYBRID\", \"HOURLY\"]</code>. Default: <code>\"HYBRID\"</code>.</li> </ul>"},{"location":"schema/geometric_bi_rectangle_constrained.schema/","title":"JSON Schema","text":""},{"location":"schema/geometric_bi_rectangle_constrained.schema/#properties","title":"Properties","text":"<ul> <li><code>b_min</code> (number, format: Meters, required): Minimum borehole-to-borehole spacing. Minimum: <code>0</code>.</li> <li><code>b_max_x</code> (number, format: Meters, required): Maximum borehole-to-borehole spacing in x-direction. Minimum: <code>0</code>.</li> <li><code>b_max_y</code> (number, format: Meters, required): Maximum borehole-to-borehole spacing in y-direction. Minimum: <code>0</code>.</li> <li><code>max_height</code> (number, format: Meters, required): Maximum height, or active length, of each borehole heat exchanger. Minimum: <code>0</code>.</li> <li><code>min_height</code> (number, format: Meters, required): Minimum height, or active length, of each borehole heat exchanger. Minimum: <code>0</code>.</li> <li><code>property_boundary</code> (array, format: Meters, required): (x, y) coordinate points of closed polygon defining property boundary. Points should be entered in a counter-clockwise fashion.</li> <li>Items (array)<ul> <li>Items (array): Length must be equal to 2.</li> <li>Items (number): Minimum: <code>0</code>.</li> </ul> </li> <li><code>no_go_boundaries</code> (array, format: Meters, required): (x, y) coordinate points of closed polygon defining go/no-go boundaries. Go/no-go zones must lie within the area defined in 'property_boundary'. Points should be entered in a counter-clockwise fashion.</li> <li>Items (array)<ul> <li>Items (array): Length must be equal to 2.</li> <li>Items (number): Minimum: <code>0</code>.</li> </ul> </li> <li><code>method</code> (string, required): Design algorithm specified. Must be: <code>\"BIRECTANGLECONSTRAINED\"</code>.</li> </ul>"},{"location":"schema/borehole.schema/","title":"JSON Schema","text":""},{"location":"schema/borehole.schema/#properties","title":"Properties","text":"<ul> <li><code>buried_depth</code> (number, format: Meters, required): Depth of top of borehole below the ground surface. Minimum: <code>0</code>.</li> <li><code>diameter</code> (number, format: Meters, required): Diameter of borehole.</li> </ul>"},{"location":"schema/soil.schema/","title":"JSON Schema","text":""},{"location":"schema/soil.schema/#properties","title":"Properties","text":"<ul> <li><code>conductivity</code> (number, format: Watts/Meter-Kelvin, required): Thermal conductivity. Minimum: <code>0</code>.</li> <li><code>rho_cp</code> (number, format: Joules/Meter^3-Kelvin, required): Volumetric heat capacity. Minimum: <code>0</code>.</li> <li><code>undisturbed_temp</code> (number, format: Centigrade, required): Undisturbed, far-field soil temperature.</li> </ul>"},{"location":"schema/geometric_rowwise.schema/","title":"JSON Schema","text":""},{"location":"schema/geometric_rowwise.schema/#properties","title":"Properties","text":"<ul> <li><code>perimeter_spacing_ratio</code> (number, format: fraction, required): The ratio between the minimum spacing between boreholes placed along the property and no-go zones and the standard borehole-to-borehole spacing used for internal boreholes. Minimum: <code>0</code>.</li> <li><code>max_spacing</code> (number, format: Meters, required): The largest minimum spacing that will be used to generate a RowWise field. Minimum: <code>0</code>.</li> <li><code>min_spacing</code> (number, format: Meters, required): The smallest minimum spacing that will be used to generate a RowWise field. Minimum: <code>0</code>.</li> <li><code>spacing_step</code> (number, format: Meters, required): The distance in spacing from the design found in the first part of first search to exhaustively check in the second part. Minimum: <code>0</code>.</li> <li><code>max_rotation</code> (number, format: Degrees, required): The maximum rotation of the rows of each field relative to horizontal that will be used in the search. Minimum: <code>-90</code>. Maximum: <code>90</code>.</li> <li><code>min_rotation</code> (number, format: Degrees, required): The minimum rotation of the rows of each field relative to horizontal that will be used in the search. Minimum: <code>-90</code>. Maximum: <code>90</code>.</li> <li><code>rotate_step</code> (number, format: Degrees, required): Step size for field rotation search.</li> <li><code>max_height</code> (number, format: Meters, required): Maximum height, or active length, of each borehole heat exchanger. Minimum: <code>0</code>.</li> <li><code>min_height</code> (number, format: Meters, required): Minimum height, or active length, of each borehole heat exchanger. Minimum: <code>0</code>.</li> <li><code>property_boundary</code> (array, format: Meters, required): (x, y) coordinate points of closed polygon defining property boundary. Points should be entered in a counter-clockwise fashion.</li> <li>Items (array): Length must be equal to 2.<ul> <li>Items (number): Minimum: <code>0</code>.</li> </ul> </li> <li><code>no_go_boundaries</code> (array, format: Meters, required): (x, y) coordinate points of closed polygon defining go/no-go boundaries. Go/no-go zones must lie within the area defined in 'property_boundary'. Points should be entered in a counter-clockwise fashion.</li> <li>Items (array)<ul> <li>Items (array): Length must be equal to 2.</li> <li>Items (number): Minimum: <code>0</code>.</li> </ul> </li> <li><code>method</code> (string, required): Design algorithm specified. Must be: <code>\"ROWWISE\"</code>.</li> </ul>"},{"location":"schema/design.schema/","title":"JSON Schema","text":""},{"location":"schema/design.schema/#properties","title":"Properties","text":"<ul> <li><code>flow_rate</code> (number, format: Liters/Second, required): Volumetric design flow rate. Value specified will be either the system or per-borehole flow rate depending on the 'flow_type' set. Minimum: <code>0</code>.</li> <li><code>flow_type</code> (string, required): Indicates whether the design volumetric flow rate set on on a per-borehole or system basis. Must be one of: <code>[\"BOREHOLE\", \"SYSTEM\"]</code>.</li> <li><code>max_eft</code> (number, format: Centigrade, required): Maximum heat pump entering fluid temperature.</li> <li><code>min_eft</code> (number, format: Centigrade, required): Minimum heat pump entering fluid temperature.</li> <li><code>max_boreholes</code> (number): Maximum number of boreholes in search. Optional. Applies to rectangular and near-square design algorithms. If unspecified, the search space will be bounded by the size of the GHE boundary.</li> <li><code>continue_if_design_unmet</code> (boolean): Causes to return the best available borehole  field configuration rather than fail if design conditions  are unmet.  Optional. Default False.</li> </ul>"}]}